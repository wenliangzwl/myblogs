
### RocketMq核心概念

#### 1 消息模型（Message Model）
   
   RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。
   
#### 2 消息生产者（Producer）
   
   负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。

#### 3 消息消费者（Consumer）
   
   负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。

#### 4 主题（Topic）
    
   表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。

#### 5 代理服务器（Broker Server）
     
   消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。
   
#### 6 名字服务（Name Server）
   
   名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。

#### 7 拉取式消费（Pull Consumer）
     
   Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。

#### 8 推动式消费（Push Consumer）
   
   Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。
   
#### 9 生产者组（Producer Group）
   
   同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

#### 10 消费者组（Consumer Group）
     
   同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。

####  11 集群消费（Clustering）
   
   集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。
   
#### 12 广播消费（Broadcasting）
     
   广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。

#### 13 普通顺序消息（Normal Ordered Message）
   
   普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。

#### 14 严格顺序消息（Strictly Ordered Message）
   
   严格顺序消息模式下，消费者收到的所有消息均是有顺序的。

#### 15 消息（Message）
   
   消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。

#### 16 标签（Tag）
   
   为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。

###  RocketMq的一些细节

   1： RocketMq 默认消费行为是无序的， 但是可以保证局部有序（单队列内） 具体解决方案为：
   
   生产者发送消息时指定队列（根据业务IDHash等等。。。） ，同时消费者使用有序消费监听器（MessageListenerOrderly） 两者同时实现 即可保证局部有序
   
   2：  rocketmq的消息通讯机制是由推（push）拉（pull）两种方式实现 不过rocketmq对推送机制做了优化现在已不需要拉取了 
    
   rocketmq的推送机制原理： 由客户端定时与mq发起pull长连接  若无消息返回 则间隔一定时间断开连接重连
   
   3：消息长度的计算公式：topic名称长度+消息传递过去的参数+消息体大小+20b(日志数据大小)）=单条消息大小
   
   单次批量发送消息大小最好不要超过1MB（会影响性能） 不能超过4MB（会直接报错） 可以通过消息分割解决(单条消息不能用消息分割)
    
   4: MQ分布式事务解决方案的思想为数据最终一致
   
   即 A B 2个微服务事务操作， 不保证A B 事务操作的原子性  但保证2者100%执行成功

   **生产者组：**
      
   当生产者组内有生产者无法提供事务回调的时候
   
   就会由组内其他生产提供事务回调
   
   **消费者组 ：** 
   
   同一组内消费者可以通过负载均衡和广播的形式消费topic    
   
   负载均衡：
    
   此消费方式会按照6种逻辑均摊topic的消息：
    
         1 AllocateMessageQueueAveragely：顺序分页
         2:AllocateMessageQueueAveragelyByCircle 环状分页
         3:AllocateMachineRoomNearby 就近机房
         4: AllocateMessageQueueByMachineRoom 指定机房
         5:AllocateMessageQueueByConfig 指定队列
         6: AllocateMessageQueueConsistentHash hash环
   
   注意 当消费者数量大于队列数量的时候 就会有消费者无法消费

   广播：
      
      此消费方式当topic每收到一条消息 所有以广播形式监听的消费者 都会收到这一条消息
   
   消息重试：
     
     当mq没有接收到消费者消费响应 或是接收到重试响应 或是发生异常时
     mq就会重发此条消息
     每次重发会间隔不相等时间  间隔时间越来越大 最大2小时
    当重试默认到达16次时此消息就会进入死信队列
    死信队列默认禁止读写（即不能往里面发送消息和不能消费消息） 可以通过配置开启读写功能
    当产生死信消息时死信队列才会跟着创建
   
   集群：
   
   rocketmq集群 总共4种角色
   
   1.生产者集群（组）
   2.消费者集群（组）
        
   3.nameserver集群
   
   nameserver集群之间并没有数据同步，  也没有任何的交互  当有新的nameserver加入集群时 broker会把自己的数据上报到新的nameserver 保持nameserver之间数据统一
   
   4.broker集群
   
   broker集群分为4种模式
   
   **单主**
       
   此模式即单独搭建一个 broker 就是咱们测试的模式， 一般只能作用于测试使用，不推荐线上使用， 一旦broker宕机 整个消息服务不可用
   
   **多主**
   
   此模式优点在于配置简单且支持容错， 但是单主节点宕机会导致部分消息(存在于此节点上的消息)无法消费(无法消费不代表消息丢失， 当此节点恢复时 依然可以消费，也就是消息存在延迟) 
   
   **多主多从:**
   
   多主多从模式 采用 主节点与从节点配合工作的模式架构  主节点提供读写 从节点只提供读  
   
   在消息发送这一块 只要有任意一个主节点(如果只剩下从节点存活 则消息发送不可用)存活 都不会影响消息发送
   
   在消息消费这一块 只要有任意节点存活（无论主从） 消息均可消费
   
   消息生产到主节点后 由主节点复制到从节点 完成消息的统一
   
   **同步**
   
   即 同步方式去复制消息， 当复制消息完成后 才通知生产者
   
   异步
    
   异步方式复制消息， 即收到消息后就通知生产者并异步复制消息 （对比同步模式， 效率提升约10%,但是当节点宕机，会出现少量消息丢失）
   
   刷盘机制：
   
   刷盘 即 吧数据存储进磁盘的操作
   
   分为同步刷盘与异步刷盘 
   
   线上推荐使用的集群架构方案： 同步复制+异步刷盘 （消息100%不丢失，且一定程度保证效率）