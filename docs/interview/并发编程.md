### 并发编程

#### 线程池的原理，为什么要创建线程池？创建线程池的方式；

   1. 
   
   2. 
   
   3. ThreadPoolExecutor、ThreadScheduledExecutor、ForkJoinPool

#### 线程的生命周期，什么时候会出现僵死进程；
   
  ![](interview.assets/线程生命周期.png)
  
  僵死进程是指子进程退出时,父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵死进程。

#### 说说线程安全问题，什么是线程安全，如何实现线程安全
    
   线程安全 - 如果线程执行过程中不会产生共享资源的冲突，则线程安全。 
   
   线程不安全 - 如果有多个线程同时在操作主内存中的变量，则线程不安全
   
   实现线程安全的三种方式: 
    
       1. 互斥同步： 临界区:syncronized、ReentrantLock； 信号量: semaphore、 互斥量: mutex
       
       2. 非阻塞同步： CAS
       
       3. 无同步方案： 可重入代码、线程本地存储

#### AQS 实现锁的原理？与 synchronize 的区别

#### Reactor 线程模型有哪些？Netty 是如何支持这三种线程模型的？

#### 多路复用器的实现原理？

#### epoll 的实现原理？epoll、poll、select 的区别
    
#### ThreadLocal 的实现原理？

#### 使用 ThreadLocal 需要注意哪些问题？（实际上是问 ThreadLocal 内存泄漏的问题）

#### Java 中的锁有哪些？和 Lock 的区别

#### synchronized 的底层实现原理？

#### AQS 的实现原理？

#### volatile 的作用和实现原理？

#### 线程池的实现原理？线程池满了，再提交任务时会怎么处理？

#### Netty 的线程模型？主从多线程模型下，线程是如何分工的？

#### 线程池的实现原理是什么？如何设置线程池的参数？

#### 对于 CPU 密集型的系统，为什么线程个数设置为 CPU 核数+1？为什么要+1？

#### 对于 IO 密集型的系统，为什么线程个数为 2 倍 CPU 核数？为什么是 2 倍，而不是 3 倍、4 倍等等？

#### BIO、NIO、AIO 的区别？

#### 什么是 JMM 内存模型？

#### synchronized 的实现原理

#### 线程池的实现原理？有哪些参数，分别是什么含义？

#### Netty 的线程模型有哪些？

#### 什么是 TCP 的粘包与半包？Netty 是如何解决的？

#### epoll 的原理？

#### 什么是内存模型？

#### 什么是线程安全？

#### Java 中锁有哪些？synchronize 和 Lock 的区别？

#### synchronize 的底层实现原理

#### 对象在内存中的布局？

#### volatile 关键字的实现原理？

#### 什么是原子性、可见性、有序性？什么是 happen-before 原则？解释一下 final 的语义？

#### 什么是 CAS？CAS 存在什么问题？

#### Lock 系列锁的实现原理？

#### 什么是原子类？原子类的实现原理？

#### Java 中对象的引用有哪些类型？

#### netty 用过吗？为什么 netty 是高性能的网络框架？

#### synchronized 底层实现

1. 同步方法
   
   可以看到在add方法的flags里面多了一个ACC_SYNCHRONIZED标志，这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。

2. 同步代码块

   从反编译的同步代码块可以看到同步块是由monitorenter指令进入，然后monitorexit释放锁，在执行monitorenter之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加1。当执行monitorexit指令时，锁的计数器也会减1。当获取锁失败时会被阻塞，一直等待锁被释放。

   但是为什么会有两个monitorexit呢？其实第二个monitorexit是来处理异常的，仔细看反编译的字节码，正常情况下第一个monitorexit之后会执行goto指令，而该指令转向的就是23行的return，也就是说正常情况下只会执行第一个monitorexit释放锁，然后返回。而如果在执行中发生了异常，第二个monitorexit就起作用了，它是由编译器自动生成的，在发生异常时处理异常然后释放掉锁。

#### volatile的原理

   为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。

   但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。

   但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议

   缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

   所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。

