### 网络相关题 

#### 1. 什么是 tcp 网络分层 

    1. 应用层 http get/http/1.1 

    2. 传输层 tcp头+http

    3. 网络互联层 ip头+tcp头+http

    4. 网络访问层 以太网+ip头+tcp头+http 

    5. 物理层 硬件+以太网+ip头+tcp头+http

   分层的好处: 

    1. 各层独立: 限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道上下层是如何工作的，增加或修改一个应用层协议不会影响传输层协议

    2. 灵活性好: 比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层 

    3. 易于测试和维护: 提高了可测性，可以独立的测试定层，某一层有了更好的实现可以整体替换掉

    4. 能促进标准化: 每一层职责清楚，方便进行标准化。

#### 2. tcp 的三次握手为什么是三次，为什么不是两次、四次？ 

    tcp 是提供面向连接的通讯传输，所以需要在进行传输之前做好两端直接的准备(server/client) 

    1. 客户端 向 服务端 发送 syn 

    2. 服务端 向客户端 发送 syc + ack 

    3. 客户端 向服务端 发送 ack 

    为什么做三次？

    如果只是做两次的话，没有办法确认客户端的接收能力 ，两次四次会浪费资源 

#### 3. tcp 的四次挥手 为什么是四次，为什么不能是三次？

    tcp 的四次挥手是终止一个 tcp 的连接

    1. 客户端 向 服务端 发送 fin + ack 

    2. 服务端 向 客户端 发送 ack 

    3. 服务端 向 客户端 发送 fin 

    4. 客户端 向 服务端 发送 ack 

    为什么做四次? 

    如果是三次的话，将2、3 步合成一次，但是 第三步 的执行时间是不太确认的，可能会很长时间才会完成，此时 客户端超时会再次发送请求，如果超时太长，会一直再发送请求 
    这样的话就会造成资源的浪费，如果是5次的话，也是会造成资源的浪费。

#### 4. 为什么 syn / fin 不包含 数据 却要消耗一个序列号 

    凡是对端的确认，是一定要序列号的，不然的话会因为网络的原因 可能进行重发，从而造成资源的浪费 

#### 5. 神是 半连接队列？ 什么事 syn flood 攻击 

    客户端大量伪造ip 发送 syn 包，服务端 回复 ack + syn 去到了一个 未知的ip 地址，势必会造成服务端大量的连接处于 syn_rcvd 状态，
    而服务器的半连接队列大小是有限的，如果半连接队列满了，也是会出现无法处理正常请求的情况.

#### 6. tcp 报文中的时间戳有什么作用？

    1. 计算往返的时延

    2. 防止序列的回绕问题

#### 7. tcp 的超时 重传时间是如何计算的？

    tcp 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包，这个重传间隔 也叫 超时重传时间 

    1. 往返时延(rtt): 一个最简单的想法就是 取平均值，比如 第一次 rtt 为 500ms, 第二次rtt 为 800ms 那么 第三次 发送时，各让一步，取平均值 为 650ms 

    2. 经典算法引入了 平滑往返时间(srtt): 经过平滑后的 rtt 的值，每测量一次rtt 就对 srtt 做一次更新计算。

#### 8. 能不能说一说 tcp 的流量控制？

   对于 发送端 和接收端而言，tcp 需要把发送的数据放到发送缓存区，将接收的数据放到 接收缓存区。 

   而流量控制要做的事情，就是在通过接收缓存区的大小，控制发送端的发送.如果对方的接收缓存区满了，就不能再继续发送了。

   为了控制 发送到端的速率，接收端 会告知 客户端 自己接收窗口，也就是 接收缓冲区中空闲的部分

#### 9. 如何 理解 tcp 的 keep-alive 的原理？ 

   一个tcp 连接上，如果通信双方都不向 对方发送数据，那么tcp 连接 就不会 有任何数据交换

   假如应用程序是一个web 服务器，客户端发送三次握手以后故障宕机或者网线断掉，对于web 服务器而言，下一个数据包将永远无法到来，但是它一无所知。

   tcp 协议设计值考虑到 这种检测长时间死连接的需求，于是乎设计了 keepalive 机制。 

   它的作用就是探测对端的连接有没有效，通过定时发送探测包来探测连接的对端是否存活，不过默认情况下需要7200s 没有数据包交互才会发送 keepalive 探测包，
   往往这个时间太久，熟知的很多组件都没有开启keepalive 特性，而是选择在应用鞥做心跳机制。

#### 10. telnet 的用法

    1. 检查 端口是否打开 

    2. telnet 发送http 请求 

#### 11. tcpdump 的用法 

   tcpdump 是一个命令行的网络流量分析工具，功能强大，一般用来抓tcp 的包。

#### 12. tcp 和 udp 的区别

    tcp 是一个面向连接的，可靠的，基于字节流的传输层协议

    udp 是一个面向无连接的传输层协议 

    面向连接: 所谓的连接，指的是客户端和服务器的连接，在双方互相通讯之前，tcp 需要进行三次握手建立连接，而 udp 没有这个过程

    可靠性: tcp 花了非常多的功夫保证连接的可靠，这个可靠指的是哪方面呢? 

    1) tcp 有状态: tcp 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。

    2） tcp 可控性： 意识到丢包了或者网络环境不佳，tcp 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。 

#### Http 和 Https 的区别？

    http 是不安全得连接，https 是安全的连接，使用 ssl 来保证

  

   

#### select 、 poll 、 epoll 有什么区别 

   它们是 nio 多路复用的三种实现机制，是由linux 操作系统提供的。 
   
   用户空间和内核空间: 操作系统为了保护系统安全，将内核分为两个部分，一个是用户空间，一个是内核空间，用户空间不能直接访问底层的硬件设备，必须通过
   内核空间。
   
   文件描述符 File Descriptor(FD): 它是一个抽象的概念，形式上是一个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。
   当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD, UNIX、LINUX 
   
   select机制: 会维护一个fd 的结合的fd_set ,将 fd_set 从用户空间复制到内核空间，激活socket。 fd_set 是一个数组结构
   
   poll机制: 和 select 机制差不多，把 fd_set 结构进行了优化，fd 集合的大小就突破了操作系统的限制。使用 pollfd 来代替fd_set ，通过链表实现。 
   
   epoll机制: 基于 event poll, epoll 不在扫描所有的fd, 只讲用户关系的fd 的事件放到内核的一个事件表当中。这样，可以减少用户空间与内核空间直接需要拷贝的数据。
   
   总结: 
   
               操作方式     底层实现     最大连接数       io效率 

   select:     遍历          数组          受限于内核       一般 
   
   poll:       遍历          链表             无上限         一般 
   
   epoll       事件回调        红黑树            无上限         高 
   
   java 中 NIO 当中是用哪种机制?   
   
      与操作系统有关 ，可以查看DefaultSelector 源码

      在 window 下 ， WindowSelectorPrivider 

      在 linux 下， 根据 linux 的内核版本， 2.6版本以上 ，就是 EPollSelectorPrivider ,否则就是 PollSelectorProvider .

   select 1987年出现，  poll 1997年  epoll 2002 年 
   
#### java 有哪几种io 模型 ，有什么区别 

   bio : 同步阻塞
   
   nio : 同步非阻塞
   
   aio : 异步非阻塞io 
   
   同步、异步 和 阻塞、非阻塞： 
   
   在一个网络请求中， 客户端会发送一个请求到服务端： 
   
   1. 客户端发了一个请求，就一直等着服务端响应。 客户端 ： 阻塞 ， 请求 : 同步 

   2. 客户端发了请求，就去干别的事，时不时的过来检查服务端是否给出了响应。 客户端： 非阻塞。 请求： 同步 

   3. 换成异步请求，客户端发了请求后，就坐在椅子上，等待着服务端返回响应， 客户端 ： 非阻塞  请求： 异步 

   4. 客户端发了请求后，就去干别的事，等到服务端给出响应后，再过来处理业务逻辑， 客户端： 非阻塞，  请求： 异步 

#### java nio 的几个核心组件是什么？ 分别有什么作用 

   channel 类似于流， 每个channel 对应一个buffer 缓存区。 channel 会注册到selector. 
   
   selector 会根据 channel 上发生的读写事件，将请求交由某个空闲的线程处理，selector 对应一个或者多个线程。 

   buffer 和 channel 都是可读可写的。