### mq 面试题 

#### 如何保证消息的顺序性？


rabbitmq 顺序性 

    拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确 实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

消息有序指的是可以按照消息的发送顺序来消费。 
    
    假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？

解决方案： 
    
    （1）保证生产者 - MQServer - 消费者是一对一对一的关系

缺陷： 
    
    并行度就会成为消息系统的瓶颈（吞吐量不够） 
    更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我 们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解 来规避。
    不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依 
    赖于消息系统，是一种更合理的方式。

#### 如何保证消息不被重复消费？

造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 

消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与 去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。

#### 线上 MQ 出现消息大量积压，应该如何处理？

   消息积压情况：
      
       1. 消费者宕机积压
       2. 消费者消费能力不足
       3. 发送者发流量太大
   
   解决方案：

        1. 上线更多的消费者，进行正常消费上线专门的队列消费服务，将消息先批量取出来，记录数据库，再慢慢消费

#### 消息队列的选型？RocketMQ 的实现原理？

#### 如何保证消息不丢失？

    消息不可靠的情况可能是消息丢失，劫持等原因； 
    丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；
        
    生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供 transaction和confirm模式来确保生产者不丢消息； transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发 送消息，如果发送过程中出现什么异常，事务就会回滚 （channel.txRollback()）,如果发送成功则提交事务 （channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布 的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的 队列之后； rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者 知道消息已经正确到达目的队列了； 如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试 操作。 
    
    消息队列丢数据：消息持久化。 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再 给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信 号，生产者会自动重发。 那么如何持久化呢？ 这里顺便说一下吧，其实也很容易，就下面步    
        1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列 
        2. 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 
    
    消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动 确认消息即可！ 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息； 如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。

#### 让你设计一个 MQ，你会如何设计？

#### RocketMQ 的实现原理。

#### RocketMQ 事务消息的实现原理？你们的项目中是如何通过 RocketMQ 来保证数据一致性

#### RocketMQ 的实现原理？消息时如何存储的？

#### 线上出现 MQ 丢失消息？问题可能出现在哪儿？如何保证 MQ 的消息不丢失？

   1. 生产者 发送消息 

   2. broker 存储消息 

   3. 消费者 消费消息 

   解决: 

    1. 生产者发送消息不丢失  
    
        kafka: 消息发送+回调 

        rocketmq: 消息发送+ 回调 ， 事务消息 

        rabbitmq : confirm + ack 


#### 如何保证 RocketMQ 的高可用性？

#### RocketMQ 的事务消息的实现原理？

#### 消息队列的选型？RocketMQ 的实现原理？

#### 如何保证消息不丢失？如何保证不重复消费消息？

#### kafka 为什么比 rocketmq 的吞吐量要高 

   kafka 的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到broker 而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定得数量的时候
   再批量发送给broker.这种做法减少了网络io,从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka 利用此机制
   提高了性能却降低了可靠性。
   
#### kafka 的pull 和 push 分别有什么优缺点

   1. pull 表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull 可以由消费者自己控制，根据自己的消费处理能力，来进行控制。但是消费者不能机制知道是否有消息，
   可能会拉到的消息为空。
      
   push 表示主动给消费者推送消息，所以是有消息才会推送，但是消费者不能按照自己能力来消费消息，推过来多少消息，消费者就得主动消费多少消息，所以可能会造成
   网络堵塞，消费者压力大等问题。

#### kafka 消息丢失的场景及解决方案

1. ack=0 ， 不重试， producer 发送消息完，不管结果，如果发送失败也就丢失了

2. ack = 1 ,leader crash ,producer 发送消息完，只等待 leader 写入成功就返回，leader carsh 了，这是follower 没来的及同步，消息丢失。

3. unclean.leader.election.enable: ture
   
#### kafka 消息高可靠解决方案

   消息发送： 
    
    ack 0: 不重试 1： leader 写入成功就返回了  all/-1 : 等待ISR 同步完再返回。
   
    unclean.leader.election.enable: false ,禁止选举ISR 以外的follower为leader 

    tries > 1 : 重试次数 

    min.insync.replicas > 1 ： 同步副本数，没满足该值前，不提供读写服务，写操作会异常。

   消息消费: 
   
    手工提交offset 

   broker ： 减少刷盘间隔

   事务消息 
   
#### kafka 高性能高吞吐的原因

   1. 磁盘的顺序读写： 保证了消息的堆积 

   2. 零拷贝: 避免CPU 将数据从一块拷贝到另一块存储的技术 

   3. 分区分段+索引

   4. 批量压缩：多条消息一起压缩，降低带宽

   5. 批量读写

   6. 直接操作 page cache ,而不是jvm ,避免gc 耗时及对象创建耗时，且读写速度更高，进程重启，缓存也不会丢失。

#### mq 如何保证消费幂等性 
    
   其实就是要防止消费者重复消费消息的问题。 
   
   所有mq 产品并没有提供主动解决幂等性的机制，需要由消费者自己解决
   
   rocketmq: 给每个消息分配了个messageid, 这个 messageid 就可以作为消费者判断幂等的依据，这种方式不太建议 
   
    最好的方式就是自己带一个有业务标识的id, 来进行幂等判断

    统一id 分配。

#### mq 如何保证分布式事务的最终一致性 

   分布式事务： 业务相关的多个操作，保证他们同时成功或者同时失败
   
   最终一致性： 与之对应的就是强一致性
   
   mq 中要保护事务的最终一致性，就需要做到两点
   
    1. 生产者要保证100% 的消息投递，事务消息机制

    2. 消费者这一端需要保证幂等消费，唯一ID + 业务自己实现幂等 

   分布式mq的三种语义: 
   
    1. at least once : 最少一次 

    2. at most once ： 最多一次

    3. exactly once : 刚刚好一次