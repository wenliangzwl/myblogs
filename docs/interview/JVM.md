### JVM 题目

#### JVM 主要组成部分及作用

   JVM 主要包括两个子系统和两个组件组成。其中两个子系统为 Class loader(类装载) 和 Execution engine(执行引擎); 
   两个组件为 Runtime data area(运行时数据区)、Native Interface(本地接口)
   
   1. 类装载(class loader): 根据给定的全限定名(如:java.lang.Object)来 装载class文件到 运行时数据区中的方法区里。
   
   2. 执行引擎(Execution engine): 执行classes 中的指令
   
   3. 本地接口(Native Interface)： 与本地方法库交互，是其他的编程语言互相交互的接口
   
   4. 运行时数据区域(Runtime data area): 就是JVM 的内存
   
   *作用:* 首先通过编译器将java代码编译成字节码，类加载器再把字节码加载到内存,将其放到运行时数据区的方法区内。
   但是字节码文件只是JVM 的一套指令集的规范，并不能直接交给底层的操作系统去执行，所以需要特定的命令解析器(也就是执行引擎)，将字节码翻译成底层系统指令，
   然后再交给CPU 去执行， 这个过程需要调用其他语言的 本地库接口来实现整个程序的功能.

#### JVM 中有哪些数据区域？
  
  ![堆](interview.assets/堆.png)

  ![](interview.assets/虚拟机栈.png)

####  JVM 运行时数据区域
  
  java虚拟机在执行java程序的时候会把它所管理的内存区域划分为很多个不同的数据区域，其中每个区域都有各自的用途，以及创建销毁时间，
  有些区域是随着虚拟机进程的启动而存在，有些区域是依赖线程的启动而存在。
  
  ![jvm运行时数据区域](interview.assets/jvm内存结构.png)
  
  程序计数器: 指向当前线程正在执行的字节码的地址,行号，线程私有
  
  虚拟机栈: 存储局部变量表，操作数栈，动态链接，方法出口等。
  
  本地方法栈: 同虚拟机栈，不同的是，它存的是本地方法的数据。
  
  堆: 虚拟机中内存最大的一块区域，被所有线程共享，几乎所有的对象实例都在这里分配内存
  
  方法区: 存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据.

#### 堆栈的区别 
   
   物理地址: 
      
      堆的物理地址分配对对象来说是不连续的，所以性能慢些.
      
      栈的物理地址分配是连续的，性能快些。(栈使用的是数据结构中的栈，是先进后出的原则)
      
   内存区别: 
       
      由于堆是不连续的，所以分配内存是在*运行期*确认的，因此内存大小不固定。(一般来说，堆大小远远大于栈大小)
      
      栈是连续的，所以分配的内存大小需要在编译期就确认，大小是固定的
      
   存放内容： 
      
      堆中存放的是对象的实例和数组。（关注的是数据的存储）
      
      栈: 存放的是局部变量、操作数栈、返回结果。(关注的更多的是程序方法的执行)
      
      ps: 1. 静态变量是存放在方法区的。 2. 静态的对象还是放在堆中
   
   可见度: 
      
      堆： 对整个应用程序都是共享、可见的
      
      栈: 只对当前线程可见，也叫线程私有，生命周期与线程相同
 
#### java 深拷贝与浅拷贝
   
   浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷⻉。（如果属性是基本类型(int,double,long,boolean等)，拷贝的就是基本类型的值; 如果属性是引用类型，拷贝的就是内存地址（即复制引用但不复制引用的对象） ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。）

   ![](interview.assets/浅拷贝.png)
   
   深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容，此为深拷⻉。（在具体实现深拷贝上，这里提供两个方式，重写clone()方法和序列法。）

   ![](interview.assets/深拷贝.png)

#### 对象的创建、 及主要流程、 内存分配的两种方式
     
  创建方式: 
    
    1. new关键字、 Class的newInstance、Construct的newInstance、clone、序列化
    
  创建主要流程: 
    
    1.类加载》分配内存》初始化
  
  内存分配:
    
    1. 指针碰撞： 如果内存规整,即所有用过的内存放一边，空闲的放一边，分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离。
    
    2. 空闲列表: 内存不规整,即使用的内存和空闲的内存放到了一起，虚拟机维护一个列表来记录哪些是可用的，分配内存的时候找到一块足够大的空间分配给对象实例，并更新列表上的记录。
    
  
#### 内存泄漏
   
   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中，无法被GC自动回收。
   
   java 导致内存泄漏的原因: 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，因为尽管段生命周期的对象已经不再需要了，但是因为
   长生命周期对象持有它的引用而导致不能被回收。

#### JVM 的垃圾回收机制？
   
   在java 中，我们是不需要显示的去释放对象的内存的，而是由虚拟机自行执行。
   
   JVM 中，有一个垃圾回收的线程(低优先级)， 在正常情况下是不会执行，只有在虚拟机空闲或者是堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，
   并添加到要回收的集合中，进行回收。
   
   
#### 为什么要区分新生代、老年代？

   1. 共享内存区划分 （共享内存区=持久代+堆、 持久代=方法区+其他、堆=老年代+年轻代、年轻代=eden+s0+s1）
   
   2. 参数配置: 
        
         默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
         
         默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)
         
         Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)
    
    
   3. 为什么要分为Eden和Survivor?为什么要设置两个Survivor区？
    
        如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
        
        Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
        
        设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）
        

#### JVM 如何进行垃圾回收？
   
   java堆=老年代+年轻代 
   
   年轻代=eden + s0 + s1 
   
   当 eden 区的空间满了，java 虚拟机会触发一次minor GC,以收集新生代的垃圾,存活下来的对象，转移到survivor区。
   
   大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
   
   如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
   
   老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – 包括年轻代和年老代。
   
   Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。
   
   
#### CMS 垃圾回收器的原理？

   
   是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程: 初始标记、并发标记、重新标记、并发清除 ，收集结束会产生大量的空间碎片.
   

#### 标记算法有哪些? JVM 的垃圾回收算法?
  
  标记算法: 引用计数器、 可达性分析算法         
   
  垃圾回收算法: 标记-整理、标记-清除 、复制 
    
#### GC Roots 有哪些？

   线程栈的本地变量、静态变量、本地方法栈的变量等等
    
#### 简述新生代与老年代的区别？

   新生代: 主要是用来存放新生的对象。一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。

   老年代: 老年代的对象比较稳定，所以MajorGC不会频繁执行。
   
#### 类的加载过程？什么是双亲委派机制？

   类的加载过程: 
    
   ![](interview.assets/类的加载过程.png)
   
    加载>> 验证>> 准备>> 解析>> 初始化>> 使用>> 卸载
   
   双亲委派机制:
    
    加载某个类时会先委托父加载器寻找目标类，找不到再 委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的 类加载路径中查找并载入目标类

#### 为什么要设计双亲委派机制？
 
   沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心 API库被随意篡改 
   
   避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证被加载类的唯一性
   
#### raft 协议的原理？

#### JVM 调优经验？

#### 什么是三色标记？

#### 线上 GC 有问题，如何排查？

#### 什么是三色标记？什么是安全点与安全区域？

#### 简述一下 G1 垃圾回收器的原理？
   
   标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。

#### 对象什么时候进入到老年代？什么是动态年龄判断？
    
   1. 对象年龄到达了设置的值(默认是15), 
   
   2. 大对象直接进入老年代 
   
   什么是动态年龄判断: survivor 区里 一批对象的总大小大于这个survivor 区域的内存大小50%(可以设置),那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。

#### 你们线上服务的 QPS 有多大？机器配置是多少？JVM 的参数是怎么设置的？GC 的频率？为什么要这这样配置？

#### CMS收集器和G1收集器的区别：
   
   CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
   
   G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；

   CMS收集器以最小的停顿时间为目标的收集器；
   
   G1收集器可预测垃圾回收的停顿时间

   CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
   
   G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
   

###  jvm 面试题汇总

    1. jvm 内存模型

        1) 类装载子系统： 根据给定的全限定名(如: java.lang.Object) 来装载class文件到运行时数据区的方法区里 
        2）字节码执行引擎: 执行class 中的指令
        3) 本地接口:  与本地方法库交互，是其他的编程语言互相交互的接口
        4）运行时数据区: jvm 内存
    
            私有: 栈(线程栈)、本地方法栈、程序计数器(线程计数器)
    
            共享: 堆(新生代(eden、s0、s1)、老年代)、 方法区(元空间)

	2. java类加载的全过程是怎样的？


		java的类加载器: AppClassLoader -> ExtClassLoader -> BootStrapClassLoader 

		每个类加载器都有它自己的加载目录

		java 中的类加载器: AppClssLoader,ExtClassLoader -> URLClassLoader -> SecureClassLoader -> ClassLoader 

		1) 加载: 把java字节码数据加载到jvm内存中, 并映射成jvm认可的数据结构
		2) 验证: 检查加载到的字节信息是否符合规范
		3）准备: 创建类或接口的静态变量，并赋初始值, 半初始化阶段
		4）解析: 将符号引用转为直接引用
		5) 初始化: 对类的静态变量初始化为指定的值，执行静态代码块


	3. 什么事双亲委派机制？有什么作用？ 

	   向上委托查找，向下委托加载  

	   作用: 沙箱安全、避免类的重复加载

	4. 对象在jvm 中经历的过程

		1. 用户创建一个对象，jvm 首先需要到方法区找对象的类型信息，然后再创建对象
		2. jvm要实例化一个对象，首先要在堆中先创建一个对象，-- 半初始化状态
		3. 对象首先会分配在堆内存中的新生代，然后经历一次 minor gc,对象如果存活，就会进入S区，在后续的每次gc 中，如果
			对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1，超过一定年龄后，对象进入老年代(最大年龄为15)
		4. 当方法执行结束后,栈中的指针会先移除
		5. 堆中的对象 经过full gc，就会被标记为垃圾对象，然后被gc线程清理掉

		对象的创建过程: 

			类加载: 虚拟机得到一条new指令, 首先检查这个指令的参数是否能在常量池中找到类的符号引用，并检查这个符号引用代表的类是否被加载，没有的话，
				先执行类加载过程 (new 指令表示 java 层面上的new、对象克隆、对象序列化) 

			分配内存: 类加载后，虚拟机为新生的对象分配内存，对象所需的大小在类加载完成后可确定，从堆中划分出需要的内存

			初始化: 内存分配完成,虚拟机需要将分配的内存空间都初始化为零值，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行，
				这一步操作保证了对象的示例字段在java代码中可以不赋初始值就能直接使用，程序能访问到这些字段的数据类型所对应的零值

			设置对象头: 初始化零值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如果找到类的元数据信息，对象的hash码，对象的gc分代年龄等。这些信息是放在
				对象头object Header 中的

			执行init: 即对象按照程序员的意愿进行初始化，对应到java语言层面上说，就是为属性赋值（这里与 赋零值不同，这里是由程序员赋的值），和执行构造方法.

	5. 怎样确定一个对象到底是不是垃圾？ 什么是gc root ?

		两种算法: 

			1) 引用计数器： 给对象中添加一个引用计数器, 每当有一个地方引用它，计数器加1，当引用失效，计数器减1, 计数器为0时就是不可能再被使用(难以解决循环引用问题，最终会导致内存泄漏)

			2）可达性分析算法: 将 gc roots 对象作为起点，从这个节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象 都是垃圾对象
				
		gc roots 根节点: 线程栈的本地变量、静态变量、本地方法栈的变量等


	6. jvm 有哪些垃圾回收算法？ 

		1） 复制算法: 将内存分为大小相同的两块，每次使用其中一块，当这一块的内存使用完毕后，就将还存活的的对象复制到另一块去，然后再把使用的空间一次清理掉
			优点: 每次都是对整个半区的内存回收，所以不存在内存碎片，实现简单，运行高效
			缺点: 将内存缩小为原来的一半

		2) 标记-清除算法: 算法分为标记 和清除两阶段, 标记存活的对象，回收未被标记的对象,也可以反过来，
			优点: 能够完全使用分配的内存,没有内存浪费
			缺点: 效率问题(当标记的对象过多，效率会很低), 空间问题(会产生大量的内存碎片)

		3） 标记-整理算法: 根据老年代的特点推出的标记算法，标记过程仍为 标记 与 清除, 但后续的步骤不是直接对可回收对象回收，而是让所以对象向一端移到，然后直接清理掉端边界
			以为的空间

	7. jvm 有哪些垃圾回收器？ 

	   1）Serial (串行)收集器: 是收集器最基本，时间最长的垃圾收集器，它是一个单线程收集器，它的 单线程的意义不仅仅意味着它只会适用一个垃圾收集线程去完成垃圾收集工作，
	   更重要的是在收集过程中，必须暂停其他所有的工作线程(STW)，直到收集结束（采用: 标记-整理算法）
	  
	   2）Parallel Sccvenge (并行)收集器: 是Serial 的 多线程版本，除了使用多线程进行收集，其余行为和serial类似，默认的收集线程跟cpu 核数相同（采用: 标记-整理算法）

	   3) ParNew (多线程)收集器: 是serial 的多线程版本，是一个新生代收集器，除了使用多线程进行垃圾收集外，其余行为和serial 类似. 除了serial 外，只有它能与cms 配合工作（采用: 标记-整理算法）

	   4） CMS  收集器: 是一种以获取最短回收停顿为目标的收集器。非常符合在注重用户体验的应用上使用，是HotSpot 第一款真正意义上的并发收集器，也是第一次实现了让垃圾收集器
	   	与用户线程同时工作(采用: 标记-清除算法)

	   		1. 初始标记: 暂停所有的其他线程(STW)，并记录gc roots 直接能引用的对象,速度很快
	   		2. 并发标记: 并发标记节点就是从 gc roots 的直接关联对象开始遍历整个对象图，这个过程很耗时，但是不需要停顿用户线程。
	   		3. 重新标记: 重新标记就是为了修正并发标记期间用户用户线程继续运行而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段时间稍长些，
	   		 主要使用到了三色标记里的增量更新算法做重新标记
	   		4. 并发清理: 开启用户线程，同时gc 线程 开始对未标记的区域做清扫，这个阶段如果有新增的对象会被标记为黑色不做任何处理
	   		5. 并发重置: 重置本次gc过程中的标记数据

	   	  优点: 并发收集，低停顿
	   	  缺点: 对cpu 资源敏感、无法处理浮动垃圾、会有大量的空间碎片产生、执行过程不确定性，会存在上一次垃圾回收还没执行完，又会触发垃圾回收，特别是并发标记和并发清理阶段，
	   	  还未回收完又触发full gc，也就是 ‘concurrent mode failure’，此时会进入STW,接着用serial old 垃圾收集器来回收 

	   5） G1 收集器: g1 将java 堆分为多个大小相等的独立区域(Region)，jvm 最多可以有2048 个 Region, 一般Region 大小等于堆大小除以2048，G1 保留了年轻代和老年代的
	   	概念，但不在是物理隔阂(采用: 复制算法+ 标记清除算法)

	   	 1. 初始标记: 暂停所有的其他线程，并记录下 gc roots 直接引用的对象，速度很快. 
	   	 2. 并发标记: 同 cms 的并发标记
	   	 3. 最终标记: 同cms 的 重新标记
	   	 4. 筛选回收: 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的gc停顿时间来指定回收计划，比如老年代次数有1000 个Region 都满了，但是因为根据用户的停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region 刚好200ms,那么就只能回收800Region,
	   	 尽量把gc导致的停顿时间控制在指定的范围内，这个阶段其实也可以做到与用户线程一起并发执行，但是因为只回收一部分Region ，时间成本是可以控制的，而且停顿用户线程将大幅
	   	 提高收集效率。不管是年轻代还是老年代，回收算法主要采用复制算法，将一个存活的Region 复制到另一个region中，这种不会像cms 那样，回收完因为有很多内存碎片，还得再整理一遍，g1 采用复制算法回收几乎不会有太多的内存碎片。

	8. 如何进行jvm 调优？

	    主要就是通过定制jvm 运行参数来提高java应用程序的运行数据。

	    jvm参数大致分为三类: 

	    	1. 标注指令: - 开头，这些是所有的HotSpot 都支持的参数，可以用 java -help 打印查看

	    	2. 非标准指令: -X 开头, 这些指令通常是跟特定的HotSpot 版本对应的， 可以用 java -X 打印查看

	    	3. 不稳定参数:  -XX 开头, 这一类参数是跟特定HotSpot 版本对应，并且变化非常大，资料很少，在jdk1.8 版本下,有几个常用的不稳定指令

	    	java -XX:PrintCommandLineFlags : 查看当前命令的不稳定指令

	    	java -XX:PrintFlagsInitial : 查看所有不稳定指令的默认值

	    	java -XX:PrintFlagsFinal : 查看所有不稳定指令最终生效的实际值


	9. 三色标记

		在并发过程中，标记期间应用程序还在继续执行，对象间的引用还会发生变化，所以会有多标和漏标的情况发生. 

		所以引入三色标记，把gc root 可达性分析遍历对象中遇到的对象，按照 ‘是否访问过’ 这个条件标记成三种颜色

		黑色: 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，黑色代表已经扫描过，它是安全存活的，如果有其他对象引用指向黑色对象，无需再重新扫描一遍。 

		灰色； 表示 对象已经被垃圾回收器访问过，但是这个对象上至少存在一个引用还没有被扫描过. 

		白色: 表示这个对象还未被垃圾回收器访问过，主要显示在可达性分析开始阶段，所有对象都是白色的，如果在分析结束的阶段，仍是白色对象，即表示不可达 


	   1. 多标-浮动垃圾: 在并发标记过程中，如果由于方法运行结束导致部分局部变量 gcroot 被销毁，这个gcroot 引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮gc 不会
	    回收这部分内存，这部分本该回收但是未回收的内存，被称为 浮动垃圾，浮动垃圾并不会影响垃圾回收的正确性，只需要等到下次回收时被清除


	   2. 漏标-读写屏障: 漏标会导致被引用的对象被当做垃圾对象误删除，这是严重的bug,必须要解决，有两种解决方案： 增量更新 和 原始快照(SATB)

	   	 1): 增量更新(针对新增): 就是当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次，这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就会变回 灰色对象了。 

	   	 2): 原始快照(针对删除): 就是当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色对象，将白色对象直接标记为黑色(目前就是让这种对象在本轮gc 中存活下来，待下一轮gc的时候再清除)



 