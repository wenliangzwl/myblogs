### JVM 题目

#### JVM 主要组成部分及作用

   JVM 主要包括两个子系统和两个组件组成。其中两个子系统为 Class loader(类装载) 和 Execution engine(执行引擎); 
   两个组件为 Runtime data area(运行时数据区)、Native Interface(本地接口)
   
   1. 类装载(class loader): 根据给定的全限定名(如:java.lang.Object)来 装载class文件到 运行时数据区中的方法区里。
   
   2. 执行引擎(Execution engine): 执行classes 中的指令
   
   3. 本地接口(Native Interface)： 与本地方法库交互，是其他的编程语言互相交互的接口
   
   4. 运行时数据区域(Runtime data area): 就是JVM 的内存
   
   *作用:* 首先通过编译器将java代码编译成字节码，类加载器再把字节码加载到内存,将其放到运行时数据区的方法区内。
   但是字节码文件只是JVM 的一套指令集的规范，并不能直接交给底层的操作系统去执行，所以需要特定的命令解析器(也就是执行引擎)，将字节码翻译成底层系统指令，
   然后再交给CPU 去执行， 这个过程需要调用其他语言的 本地库接口来实现整个程序的功能.

#### JVM 中有哪些数据区域？
  
  ![堆](interview.assets/堆.png)

  ![](interview.assets/虚拟机栈.png)

####  JVM 运行时数据区域
  
  java虚拟机在执行java程序的时候会把它所管理的内存区域划分为很多个不同的数据区域，其中每个区域都有各自的用途，以及创建销毁时间，
  有些区域是随着虚拟机进程的启动而存在，有些区域是依赖线程的启动而存在。
  
  ![jvm运行时数据区域](interview.assets/jvm内存结构.png)
  
  程序计数器: 指向当前线程正在执行的字节码的地址,行号，线程私有
  
  虚拟机栈: 存储局部变量表，操作数栈，动态链接，方法出口等。
  
  本地方法栈: 同虚拟机栈，不同的是，它存的是本地方法的数据。
  
  堆: 虚拟机中内存最大的一块区域，被所有线程共享，几乎所有的对象实例都在这里分配内存
  
  方法区: 存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据.

#### 堆栈的区别 
   
   物理地址: 
      
      堆的物理地址分配对对象来说是不连续的，所以性能慢些.
      
      栈的物理地址分配是连续的，性能快些。(栈使用的是数据结构中的栈，是先进后出的原则)
      
   内存区别: 
       
      由于堆是不连续的，所以分配内存是在*运行期*确认的，因此内存大小不固定。(一般来说，堆大小远远大于栈大小)
      
      栈是连续的，所以分配的内存大小需要在编译期就确认，大小是固定的
      
   存放内容： 
      
      堆中存放的是对象的实例和数组。（关注的是数据的存储）
      
      栈: 存放的是局部变量、操作数栈、返回结果。(关注的更多的是程序方法的执行)
      
      ps: 1. 静态变量是存放在方法区的。 2. 静态的对象还是放在堆中
   
   可见度: 
      
      堆： 对整个应用程序都是共享、可见的
      
      栈: 只对当前线程可见，也叫线程私有，生命周期与线程相同
 
#### java 深拷贝与浅拷贝
   
   浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷⻉。
   
   深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容，此为深拷⻉。

#### 对象的创建、 及主要流程、 内存分配的两种方式
     
  创建方式: 
    
    1. new关键字、 Class的newInstance、Construct的newInstance、clone、序列化
    
  创建主要流程: 
    
    1.类加载》分配内存》初始化
  
  内存分配:
    
    1. 指针碰撞： 如果内存规整,即所有用过的内存放一边，空闲的放一边，分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离。
    
    2. 空闲列表: 内存不规整,即使用的内存和空闲的内存放到了一起，虚拟机维护一个列表来记录哪些是可用的，分配内存的时候找到一块足够大的空间分配给对象实例，并更新列表上的记录。
    
  
#### 内存泄漏
   
   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中，无法被GC自动回收。
   
   java 导致内存泄漏的原因: 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，因为尽管段生命周期的对象已经不再需要了，但是因为
   长生命周期对象持有它的引用而导致不能被回收。

#### JVM 的垃圾回收机制？
   
   在java 中，我们是不需要显示的去释放对象的内存的，而是由虚拟机自行执行。
   
   JVM 中，有一个垃圾回收的线程(低优先级)， 在正常情况下是不会执行，只有在虚拟机空闲或者是堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，
   并添加到要回收的集合中，进行回收。
   
   
#### 为什么要区分新生代、老年代？

#### JVM 如何进行垃圾回收？标记算法有哪些？垃圾回收算法有哪些？

#### CMS 垃圾回收器的原理？

   

#### JVM 的垃圾回收算法

#### GC Roots 有哪些？

   
    
#### 简述新生代与老年代的区别？

   新生代: 主要是用来存放新生的对象。一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。

   老年代: 老年代的对象比较稳定，所以MajorGC不会频繁执行。
   
#### 类的加载过程？什么是双亲委派机制？

   类的加载过程: 
    
   ![](interview.assets/类的加载过程.png)
   
    加载>> 验证>> 准备>> 解析>> 初始化>> 使用>> 卸载
   
   双亲委派机制:
    
    加载某个类时会先委托父加载器寻找目标类，找不到再 委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的 类加载路径中查找并载入目标类

#### 为什么要设计双亲委派机制？
 
   沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心 API库被随意篡改 
   
   避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证被加载类的唯一性
   
#### 垃圾回收算法。

#### raft 协议的原理？

#### JVM 调优经验？

#### 什么是三色标记？

#### 一个对象是如何存储在 JVM 中的？

#### 类加载过程，以及方法的执行的过程？

#### JVM 的垃圾回收机制？为什么要区分新生代、老年代？

#### 线上 GC 有问题，如何排查？

#### Java 如何判断一个对象能否被回收？垃圾回收算法有哪些？

#### 垃圾标记算法和垃圾回收算法有哪些？

#### 什么是三色标记？什么是安全点与安全区域？

#### 简述一下 G1 垃圾回收器的原理？

#### 为什么你们项目中没有使用 G1 垃圾回收器？

#### 什么时候会触发 Minor GC？什么时候触发 Old GC？什么是 Full GC?

#### 对象什么时候进入到老年代？什么是动态年龄判断？

#### 你们线上服务的 QPS 有多大？机器配置是多少？JVM 的参数是怎么设置的？GC 的频率？为什么要这这样配置？

