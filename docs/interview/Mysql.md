### Mysql 相关面试题

#### 索引 

   是帮助mysql 高效获取数据的*排好序* 的 *数据结构*

#### mysql 索引 底层数据结构
   
   hash 和 B+tree 平衡查询多叉树
    
     hash 是不支持范围查询的。
     
     索引虽然能提高查询效率，但是是牺牲插入和修改的性能的，因为每次修改都需要重新维护一下索引结构，带来大量的IO 开销。
     所以对一下频繁更改且唯一性差的字段，不建议创建索引

#### 红⿊树 B-tree(B树) B+tree的区别
   
   1. B树相对于红黑树的区别
       
       在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO 读写过过于频繁，进而导致效率低下的情况。
       为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道
       ，最后对数据进行读写。磁盘IO 代价主要花费在查找所需的柱面上，数的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数
       往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度.
     
     红黑树不适合大规模数据存储  
     
   2. B树 和B+树的区别
       
       1. B树则所有节点都带有指向记录(数据)的指针(ROWID),B+树中只有叶子节点会带有指向记录(数据)的指针(ROWID)。
       因为B+树它把所有的卫星数据(或指向数据的指针)都存储在叶子节点中，内部节点只存放关键字和孩子指针，不会带上指向记录的指针(rowid)，
       这样，一个快中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点(优点1)。
       
       2. B+树中每个叶子节点都包含指向下一个叶子节点的指针。所有叶子节点都是通过指针连接在一起，而B树不会。
       叶子节点之间通过指针来连接，范围扫描将十分简单(优点2)，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动.
       
        B+树还有一个最大的好处，遍历更加高效，方便扫库(优点3)，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子节点挨个扫一遍就完了，
        B+树支持range-query 非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
        (B+树的遍历更加高效，B树需要以中序遍历的方式遍历节点，而B+树只需要把所有叶子节点串成链表就可以从头到尾遍历)。
        
       3. B+树每个节点的指针和key 一样多，B树每个节点=指针比key多1.
       
   为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引
       
       1) B+树的磁盘读写代价更低
        
          B+树的内部节点并没有指向关键字具体信息的指针，因为其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，
          那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对于IO 读写次数也就降低了。
       
       2) B+树的查询效率更稳定
          
          由于非叶子节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条
          从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
          
          数据索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，
          B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而
          B树不支持这样的操作(或者说是效率太低)
          
   
   各有优点:
       
      B+树的优点:
        
        1. 非叶子节点不会带上指向记录的指针(ROWID),这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个
        内部节点可以定位更多的叶子节点.
        
        2.叶子节点之间通过指针来连接，范围扫描将十分简单,而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。
      
      B树的优点:
        
        对于在内部节点的数据，可直接得到，不必根据叶子节点来定位.
      
      
#### Mysql 中有哪几种锁?
   
   MyISAM 支持表锁， InnoDB 支持表锁和行锁，默认为行锁
   
   表级锁: 开销小，加锁快，不会出现死锁，锁粒度大，发生锁冲突的概率最高，并发量最低
   
   行级锁: 开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高
   
#### 聚集索引和⾮聚集索引
    
   ![](interview.assets/聚集索引和非聚集索引.png)

   
   聚集索引: 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
   
   非聚集索引: 该索引中索引的 逻辑顺序与磁盘上行的物理存储顺序不同 ，一个表中可以拥有多个非聚集索引。
   
   聚集索引: 
       
   ![](interview.assets/聚集索引.png)
   
       注：第一列的地址表示该行数据在磁盘中的物理地址，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。
       
       结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。
       
   
   ![](interview.assets/聚集索引2.png)
   
       从上图可以看出聚集索引的好处了，索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。
      
   
   非聚集索引： 
       
       其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。
   
   ![](interview.assets/非聚集索引.png)
   

#### redis和mysql数据⼀致是怎么保证的
        
   读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。
   
   管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。
   
   
   举一个例子：
       
       1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
       
       2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。
       
       因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。
       
       如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。
   
   缓存和数据库一致性解决方案
   
   1. 第一种方案：采用延时双删策略
       
        
        在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
        
        public void write( String key, Object data )
        {
        	redis.delKey( key );
        	db.updateData( data );
        	Thread.sleep( 500 );
        	redis.delKey( key );
        }
        
        那么，这个500毫秒怎么确定的，具体该休眠多久呢？
        
        需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
        
        当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
        
        
        3.设置缓存过期时间从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
        
        4.该方案的弊端结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。
        
   
   2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)
       
      1. 技术整体思路
       
        MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
        
        读Redis：热数据基本都在Redis
        
        写MySQL:增删改都是操作MySQL
        
        更新Redis数据：MySQ的数据操作binlog，来更新到Redis
       
      2.Redis更新
        
        (1）数据操作主要分为两大块：一个是全量(将全部数据一次写入到redis)一个是增量（实时更新）这里说的是增量,指的是mysql的update、insert、delate变更数据。
        
        (2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
        
            这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
            
            其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
            
            这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
            
            当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!
            
#### MySQL 存储引擎的区别？
   
   1.事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。
   
   2.性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。
   
   3.行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。
   
   4.索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。
   
   MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
   
   InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。
   
   5.服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
   
   MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
   
   6.锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
   
#### MySQL 索引的数据结构是什么？为什么选择这种数据结构？
    
   mysql 索引的数据结构是 B+Tree。
   
   索引数据结构演进: 
       
       首先对于数组，链表这种线性表来说，适合存储数据，而不是查找数据，同样，对于普通二叉树来说，数据存储没有特定规律，所以也不适合。
       
        哈希索引不能满足业务需求: 哈希（Hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O（1），即一般仅需要一次查找就能定位到数据。在各种编程语言和数据库中应用广泛，如Java，Python，Redis中都有使用。
       
       哈希结构在单条数据的等值查询是性能非常优秀，但是只能用来搜索等值的查询， 对于范围查询，模糊查询（最左前缀原则）都不支持，所以不能很好的支持业务需求；所以MySQL并没有显式支持Hash索引，而是根据数据的访问频次和模式自动的为热点数据页建立哈希索引，称之为自适应哈希索引。
       
       二叉搜索树退化成链表 : 二叉搜索树，如果左子树不为空，则左子树上所有节点均小于根节点，右子树节点均大于根节点；由其属性不难看出，这种树非常适合数据查找。不过有个致命的缺点是二叉搜索树的树型取决于数据的输入顺序，极端情况下会退化成链表。
       
       平衡二叉搜索树过于严格: 为了解决上述问题，平衡二叉搜索树就诞生了。在保证数据顺序的基础上，又能维持树型，保证每个节点的左右子树高度相差不超过1。
                    
       不过由于要维持树的平衡，在插入数据时可能要进行大量的数据移动。平衡搜索二叉树过于严格的平衡要求，导致几乎每次插入和删除节点都会破坏树的平衡性，使得树的性能大打折扣。
       
        红黑树高度过高，磁盘IO次数频繁：  红黑树的深度过大，数据检索时造成磁盘IO频繁
       
       B-Tree不支持顺序查询: 一定内存的情况下可以存储的索引数量相对有限, B-Tree和红黑树对于顺序查询并不友好。
       
   B+Tree的优点可以分为以四个：
       
        充分利用空间局部性原理，适合磁盘存储。
       
        树的高度很低，能够在存储大量数据情况下，进行较少的磁盘IO
       
        能够很好支持单值，范围查询，有序性查询。
       
        索引和数据分开存储，让更多的索引存储在内存中。

#### 数据库有哪些隔离级别？这几种隔离级别分别解决了什么问题？

  隔离级别: 
        
        1.读未提交   可能发生脏读、不可重复读、幻读问题。
        
        2. 读已提交  可能发生不可重复读和幻读问题，但是不会发生脏读问题。
        
        3. 可重复读  可能发生幻读问题，不会发生脏读和不可重复读的问题。
        
        4. 串行化  各种问题都不可以发生。
        
#### 脏读 幻读 不可重复读
   
   “未提交读（read-uncommitted）”这种隔离级别是数据一致性最差的一种，会产生“脏读”、“不可重复读”、“幻读”。
   
   “已提交读（read committed）”这种隔离级别虽然解决了“脏数据”问题。但仍然存在“不可重复读”和“幻读”。
   
   虽然“ 可重复读（ repeatable read）”级别，解决了“脏数据”和“不可重复读”的问题。但是它依然存在“幻读”现象，
   
   脏读: 一个事务在处理过程中读取了另外一个事务未提交的数据
   
   不可重复读: 一个事务范围内，多次查询某个数据，却得到不同的结果 (通俗一点就是另一个事务针对这个row执行了update操作)
   
   幻读: 同一个查询条件，返回的结果不一样（有一个隐含条件，同一个row返回的结果是一样的）。再通俗一点就是另一个事务针对这个表做了delete或者insert操作。
       
#### MySQL 的可重复读隔离级别下，存在幻读吗？为什么？
    
  存在, 因为可重复读隔离级别下只能解决 脏读，和不可重复读 问题 , 幻读并不能解决。
  
  如果项目中需要解决幻读的话，可以使用 串行化读的隔离级别 ， 或者使用 MVCC +next-key locks 加锁的形式
    
#### 数据库的索引是不是创建得越多越好？为什么？通常创建几个？

   并不是建的越多越好。一般不要超过3个 （不是绝对的）
       
       1. 数据量小的表不需要建立索引，建立索引会增加额外的索引开销；
       
       2. 数据变更需要维护索引，因此更多的索引意味着更多的维护成本.
       
       3. 更多的索引意味着需要更多的空间（索引也是需要空间来存储的）
       
       

#### 一张表中对 a、b、c 三个字段分别建立了索引，现在有一条 SQL 语句：select field1,field2 ... from t where a = xx and b=xx and c=xx. 请问这条 SQL 语句会使用到索引吗？如果会，那么会使用到哪个索引？

  只会使用其中一个索引，可能是 a,也可能是 b，还有可能是 c，具体使用哪个索引和表中的数据有关
   
#### 为什么不会同时使用 a,b,c 三个索引？什么是回表？
   
   
   
#### explain 的结果有哪些列？分别代表什么含义？

#### 如何查看慢 SQL？

#### MySQL 数据库索引的实现原理？

#### 什么是回表？什么是联合索引？什么是最左前缀匹配原则？

#### MySQL 如何保证高可用？主从复制原理？

#### Explain 关键字的使用。

#### MySQL 为什么使用 B+树来作索引，对比 B 树它的优点和缺点是什么？

#### 什么是覆盖索引？

#### MySQL 索引的数据结构和原理？

#### MySQL 的调优经验

#### MySQL 的索引为什么是 B+Tree，而不是数组、Hash 之类的数据结构？为什么不是 B-Tree？

#### SQL 的优化经验有哪些？索引的设计准则？

#### 如何查看 SQL 的慢查询日志？线上服务出现慢查询了怎么处理？

#### 线上数据库出现了死锁怎么办？

#### MySQL 的 InnoDB 在可重复读隔离界别下如何解决不可重复读问题和幻读问题的？什么是快照读？什么是当前读？

#### MySQL 中有哪些锁？什么是间隙锁？

#### MySQL 中有哪些日志？

#### 数据库有哪些特性？MySQL 是如何保证机器宕机重启后，数据不丢失的？

#### binlog 有什么作用？将其格式设置为 statement 会有什么问题？你们线上是如何配置的？

#### 如何保证 MySQL 的高可用？主从复制的原理？

#### 现在线上环境中发现 MySQL 的从节点大幅落后于 master 节点，可能是什么原因？如何处理？

#### 代码在执行 SQL 语句时，数据库连接出现了超时异常，但是你不知道这条 SQL 语句在数据库中究竟有没有执行成功，这种情况怎么保证数据的一致性？
    
#### MVCC 的实现原理
    