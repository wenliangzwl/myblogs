### Mysql 相关面试题

#### mysql 索引 底层数据结构
   
   hash 和 B+tree 平衡查询多叉树
    
     hash 是不支持范围查询的。
     
     索引虽然能提高查询效率，但是是牺牲插入和修改的性能的，因为每次修改都需要重新维护一下索引结构，带来大量的IO 开销。
     所以对一下频繁更改且唯一性差的字段，不建议创建索引

#### 红⿊树 B-tree(B树) B+tree的区别
   
   1. B树相对于红黑树的区别
       
       在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO 读写过过于频繁，进而导致效率低下的情况。
       为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道
       ，最后对数据进行读写。磁盘IO 代价主要花费在查找所需的柱面上，数的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数
       往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度.
     
     红黑树不适合大规模数据存储  
     
   2. B树 和B+树的区别
       
       1. B树则所有节点都带有指向记录(数据)的指针(ROWID),B+树中只有叶子节点会带有指向记录(数据)的指针(ROWID)。
       因为B+树它把所有的卫星数据(或指向数据的指针)都存储在叶子节点中，内部节点只存放关键字和孩子指针，不会带上指向记录的指针(rowid)，
       这样，一个快中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点(优点1)。
       
       2. B+树中每个叶子节点都包含指向下一个叶子节点的指针。所有叶子节点都是通过指针连接在一起，而B树不会。
       叶子节点之间通过指针来连接，范围扫描将十分简单(优点2)，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动.
       
        B+树还有一个最大的好处，遍历更加高效，方便扫库(优点3)，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子节点挨个扫一遍就完了，
        B+树支持range-query 非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
        (B+树的遍历更加高效，B树需要以中序遍历的方式遍历节点，而B+树只需要把所有叶子节点串成链表就可以从头到尾遍历)。
        
       3. B+树每个节点的指针和key 一样多，B树每个节点=指针比key多1.
       
   为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引
       
       1) B+树的磁盘读写代价更低
        
          B+树的内部节点并没有指向关键字具体信息的指针，因为其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，
          那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对于IO 读写次数也就降低了。
       
       2) B+树的查询效率更稳定
          
          由于非叶子节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条
          从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
          
          数据索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，
          B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而
          B树不支持这样的操作(或者说是效率太低)
          
   
   各有优点:
       
      B+树的优点:
        
        1. 非叶子节点不会带上指向记录的指针(ROWID),这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个
        内部节点可以定位更多的叶子节点.
        
        2.叶子节点之间通过指针来连接，范围扫描将十分简单,而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。
      
      B树的优点:
        
        对于在内部节点的数据，可直接得到，不必根据叶子节点来定位.
      
      
#### Mysql 中有哪几种锁?
   
   MyISAM 支持表锁， InnoDB 支持表锁和行锁，默认为行锁
   
   表级锁: 开销小，加锁快，不会出现死锁，锁粒度大，发生锁冲突的概率最高，并发量最低
   
   行级锁: 开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高
   
#### 脏读 幻读 不可重复读
   
   “未提交读（read-uncommitted）”这种隔离级别是数据一致性最差的一种，会产生“脏读”、“不可重复读”、“幻读”。
   
   “已提交读（read committed）”这种隔离级别虽然解决了“脏数据”问题。但仍然存在“不可重复读”和“幻读”。
   
   虽然“ 可重复读（ repeatable read）”级别，解决了“脏数据”和“不可重复读”的问题。但是它依然存在“幻读”现象，
   
   脏读: 一个事务在处理过程中读取了另外一个事务未提交的数据
   
   不可重复读: 一个事务范围内，多次查询某个数据，却得到不同的结果 (通俗一点就是另一个事务针对这个row执行了update操作)
   
   幻读: 同一个查询条件，返回的结果不一样（有一个隐含条件，同一个row返回的结果是一样的）。再通俗一点就是另一个事务针对这个表做了delete或者insert操作。
   
   
#### 聚集索引和⾮聚集索引
   
   聚集索引: 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
   
   非聚集索引: 该索引中索引的 逻辑顺序与磁盘上行的物理存储顺序不同 ，一个表中可以拥有多个非聚集索引。
   
   
   
   
   