### Mysql 相关面试题

#### 索引 

   是帮助mysql 高效获取数据的*排好序* 的 *数据结构*

#### mysql 索引 底层数据结构
   
   hash 和 B+tree 平衡查询多叉树
    
     hash 是不支持范围查询的。
     
     索引虽然能提高查询效率，但是是牺牲插入和修改的性能的，因为每次修改都需要重新维护一下索引结构，带来大量的IO 开销。
     所以对一下频繁更改且唯一性差的字段，不建议创建索引

#### 红⿊树 B-tree(B树) B+tree的区别
   
   1. B树相对于红黑树的区别
       
       在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO 读写过过于频繁，进而导致效率低下的情况。
       为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道
       ，最后对数据进行读写。磁盘IO 代价主要花费在查找所需的柱面上，数的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数
       往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度.
     
     红黑树不适合大规模数据存储  
     
   2. B树 和B+树的区别
       
       1. B树则所有节点都带有指向记录(数据)的指针(ROWID),B+树中只有叶子节点会带有指向记录(数据)的指针(ROWID)。
       因为B+树它把所有的卫星数据(或指向数据的指针)都存储在叶子节点中，内部节点只存放关键字和孩子指针，不会带上指向记录的指针(rowid)，
       这样，一个快中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点(优点1)。
       
       2. B+树中每个叶子节点都包含指向下一个叶子节点的指针。所有叶子节点都是通过指针连接在一起，而B树不会。
       叶子节点之间通过指针来连接，范围扫描将十分简单(优点2)，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动.
       
        B+树还有一个最大的好处，遍历更加高效，方便扫库(优点3)，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子节点挨个扫一遍就完了，
        B+树支持range-query 非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
        (B+树的遍历更加高效，B树需要以中序遍历的方式遍历节点，而B+树只需要把所有叶子节点串成链表就可以从头到尾遍历)。
        
       3. B+树每个节点的指针和key 一样多，B树每个节点=指针比key多1.
       
   为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引
       
       1) B+树的磁盘读写代价更低
        
          B+树的内部节点并没有指向关键字具体信息的指针，因为其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，
          那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对于IO 读写次数也就降低了。
       
       2) B+树的查询效率更稳定
          
          由于非叶子节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条
          从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
          
          数据索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，
          B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而
          B树不支持这样的操作(或者说是效率太低)
          
   
   各有优点:
       
      B+树的优点:
        
        1. 非叶子节点不会带上指向记录的指针(ROWID),这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个
        内部节点可以定位更多的叶子节点.
        
        2.叶子节点之间通过指针来连接，范围扫描将十分简单,而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。
      
      B树的优点:
        
        对于在内部节点的数据，可直接得到，不必根据叶子节点来定位.
      
      
#### Mysql 中有哪几种锁?
   
   MyISAM 支持表锁， InnoDB 支持表锁和行锁，默认为行锁
   
   表级锁: 开销小，加锁快，不会出现死锁，锁粒度大，发生锁冲突的概率最高，并发量最低
   
   行级锁: 开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高
   
#### 聚集索引和⾮聚集索引
    
   ![](interview.assets/聚集索引和非聚集索引.png)

   
   聚集索引: 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
   
   非聚集索引: 该索引中索引的 逻辑顺序与磁盘上行的物理存储顺序不同 ，一个表中可以拥有多个非聚集索引。
   
   聚集索引: 
       
   ![](interview.assets/聚集索引.png)
   
       注：第一列的地址表示该行数据在磁盘中的物理地址，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。
       
       结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。
       
   
   ![](interview.assets/聚集索引2.png)
   
       从上图可以看出聚集索引的好处了，索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。
      
   
   非聚集索引： 
       
       其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。
   
   ![](interview.assets/非聚集索引.png)
   

#### redis和mysql数据⼀致是怎么保证的
        
   读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。
   
   管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。
   
   
   举一个例子：
       
       1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
       
       2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。
       
       因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。
       
       如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。
   
   缓存和数据库一致性解决方案
   
   1. 第一种方案：采用延时双删策略
       
        
        在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
        
        public void write( String key, Object data )
        {
        	redis.delKey( key );
        	db.updateData( data );
        	Thread.sleep( 500 );
        	redis.delKey( key );
        }
        
        那么，这个500毫秒怎么确定的，具体该休眠多久呢？
        
        需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
        
        当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
        
        
        3.设置缓存过期时间从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
        
        4.该方案的弊端结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。
        
   
   2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)
       
      1. 技术整体思路
       
        MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
        
        读Redis：热数据基本都在Redis
        
        写MySQL:增删改都是操作MySQL
        
        更新Redis数据：MySQ的数据操作binlog，来更新到Redis
       
      2.Redis更新
        
        (1）数据操作主要分为两大块：一个是全量(将全部数据一次写入到redis)一个是增量（实时更新）这里说的是增量,指的是mysql的update、insert、delate变更数据。
        
        (2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
        
            这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
            
            其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
            
            这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
            
            当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!
            
#### MySQL 存储引擎的区别？
   
   1.事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。
   
   2.性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。
   
   3.行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。
   
   4.索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。
   
   MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
   
   InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。
   
   5.服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
   
   MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
   
   6.锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
   
#### MySQL 索引的数据结构是什么？为什么选择这种数据结构？
    
   mysql 索引的数据结构是 B+Tree。
   
   索引数据结构演进: 
       
       首先对于数组，链表这种线性表来说，适合存储数据，而不是查找数据，同样，对于普通二叉树来说，数据存储没有特定规律，所以也不适合。
       
        哈希索引不能满足业务需求: 哈希（Hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O（1），即一般仅需要一次查找就能定位到数据。在各种编程语言和数据库中应用广泛，如Java，Python，Redis中都有使用。
       
       哈希结构在单条数据的等值查询是性能非常优秀，但是只能用来搜索等值的查询， 对于范围查询，模糊查询（最左前缀原则）都不支持，所以不能很好的支持业务需求；所以MySQL并没有显式支持Hash索引，而是根据数据的访问频次和模式自动的为热点数据页建立哈希索引，称之为自适应哈希索引。
       
       二叉搜索树退化成链表 : 二叉搜索树，如果左子树不为空，则左子树上所有节点均小于根节点，右子树节点均大于根节点；由其属性不难看出，这种树非常适合数据查找。不过有个致命的缺点是二叉搜索树的树型取决于数据的输入顺序，极端情况下会退化成链表。
       
       平衡二叉搜索树过于严格: 为了解决上述问题，平衡二叉搜索树就诞生了。在保证数据顺序的基础上，又能维持树型，保证每个节点的左右子树高度相差不超过1。
                    
       不过由于要维持树的平衡，在插入数据时可能要进行大量的数据移动。平衡搜索二叉树过于严格的平衡要求，导致几乎每次插入和删除节点都会破坏树的平衡性，使得树的性能大打折扣。
       
        红黑树高度过高，磁盘IO次数频繁：  红黑树的深度过大，数据检索时造成磁盘IO频繁
       
       B-Tree不支持顺序查询: 一定内存的情况下可以存储的索引数量相对有限, B-Tree和红黑树对于顺序查询并不友好。
       
   B+Tree的优点可以分为以四个：
       
        充分利用空间局部性原理，适合磁盘存储。
       
        树的高度很低，能够在存储大量数据情况下，进行较少的磁盘IO
       
        能够很好支持单值，范围查询，有序性查询。
       
        索引和数据分开存储，让更多的索引存储在内存中。

#### 数据库有哪些隔离级别？这几种隔离级别分别解决了什么问题？

  隔离级别: 
        
        1.读未提交   可能发生脏读、不可重复读、幻读问题。
        
        2. 读已提交  可能发生不可重复读和幻读问题，但是不会发生脏读问题。
        
        3. 可重复读  可能发生幻读问题，不会发生脏读和不可重复读的问题。
        
        4. 串行化  各种问题都不可以发生。
        
#### 脏读 幻读 不可重复读
   
   “未提交读（read-uncommitted）”这种隔离级别是数据一致性最差的一种，会产生“脏读”、“不可重复读”、“幻读”。
   
   “已提交读（read committed）”这种隔离级别虽然解决了“脏数据”问题。但仍然存在“不可重复读”和“幻读”。
   
   虽然“ 可重复读（ repeatable read）”级别，解决了“脏数据”和“不可重复读”的问题。但是它依然存在“幻读”现象，
   
   脏读: 一个事务在处理过程中读取了另外一个事务未提交的数据
   
  ![](interview.assets/脏读.png)
   
   不可重复读: 一个事务范围内，多次查询某个数据，却得到不同的结果 (通俗一点就是另一个事务针对这个row执行了update操作)
   
  ![](interview.assets/不可重复读.png) 
   
   幻读: 同一个查询条件，返回的结果不一样（有一个隐含条件，同一个row返回的结果是一样的）。再通俗一点就是另一个事务针对这个表做了delete或者insert操作。
       
   ![](interview.assets/幻读.png)
   
#### MySQL 的可重复读隔离级别下，存在幻读吗？为什么？
  
  
    
  存在, 因为可重复读隔离级别下只能解决 脏读，和不可重复读 问题 , 幻读并不能解决。
  
  如果项目中需要解决幻读的话，可以使用 串行化读的隔离级别 ， 或者使用 MVCC +next-key locks 加锁的形式
    
#### MySQL 的 InnoDB 在可重复读隔离界别下如何解决不可重复读问题和幻读问题的？什么是快照读？什么是当前读？
    
    解决了不可重复读，和幻读问题 , 不可重复读 因为可重复读隔离级别本身就是为了解决而存在的，但是幻读的话，是使用 MVVC(多版本并发控制) 解决的 
    
    当前读: 读取的是最新版本，并且对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。
    
    快照读: 简单的select操作(不包括 select ... lock in share mode, select ... for update)。　　　　
    
            Read Committed隔离级别：每次select都生成一个快照读。
    
    　　     Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。
    
#### 数据库的索引是不是创建得越多越好？为什么？通常创建几个？

   并不是建的越多越好。一般不要超过3个 （不是绝对的）
       
       1. 数据量小的表不需要建立索引，建立索引会增加额外的索引开销；
       
       2. 数据变更需要维护索引，因此更多的索引意味着更多的维护成本.
       
       3. 更多的索引意味着需要更多的空间（索引也是需要空间来存储的）
       
       

#### 一张表中对 a、b、c 三个字段分别建立了索引，现在有一条 SQL 语句：select field1,field2 ... from t where a = xx and b=xx and c=xx. 请问这条 SQL 语句会使用到索引吗？如果会，那么会使用到哪个索引？

  只会使用其中一个索引，可能是 a,也可能是 b，还有可能是 c，具体使用哪个索引和表中的数据有关
   
#### 如何查看慢 SQL？ 线上服务出现慢查询了怎么处理？    
    
   show variables like 'slow_query%';   // 查看是否开启慢查询功能
   
   slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）
   
   show variables like 'long_query_time';  // 查询超过多少秒才记录
   
   通过命令临时开启 
    
    set global slow_query_log='ON';
   
    set global slow_query_log_file='/var/lib/mysql/instance-1-slow.log';
    
    set global long_query_time=2;

   永久配置
    
    修改配置文件达到永久配置状态：
    
    /etc/mysql/conf.d/mysql.cnf
    [mysqld]
    slow_query_log = ON
    slow_query_log_file = /var/lib/mysql/instance-1-slow.log

    
#### MySQL 数据库索引的实现原理？

#### 什么是回表？ 什么是覆盖索引？ 什么是联合索引？什么是最左前缀匹配原则？

   什么是回表:  先通过普通索引定位主键值，再通过聚集索引定位行记录，它的性能较扫一遍索引树更低。
   
   什么是覆盖索引: 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
    
     如何实现覆盖索引: 
           
           将被查询的字段，建立到联合索引里去。 不需要回表查询
   
   什么是联合索引:  是指对表上的多个列合起来做一个索引. 联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列
   
   什么是最左前缀匹配原则： 在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

#### SQL 的优化经验有哪些？索引的设计准则？

   1. 选择唯一性索引
   
   2. 为经常需要排序，分组和联合操作的字段建立索引
   
   3. 为常作为查询条件的字段建立索引
   
   4. 限制索引的数目
   
   5. 尽量使用数据量少的索引
   
   6. 数据量小的表最好不要使用索引
   
   7. 尽量使用前缀来索引
   
   8. 删除不再使用或者很少使用的索引 

#### 线上数据库出现了死锁怎么办？
   
   1. 线上错误日志报警发现死锁异常
   
   2. 查看错误日志的堆栈信息
   
   3. 查看 MySQL 死锁相关的日志
   
   4. 根据 binlog 查看死锁相关事务的执行内容
   
   5. 根据上述信息找出两个相互死锁的事务执行的 SQL 操作，根据本系列介绍的锁相关理论知识，进行分析推断死锁原因
   
   6. 修改业务代码

#### MySQL 中有哪些锁？什么是间隙锁？

   行锁： InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。
   
   记录锁（Record Locks）: 记录锁就是为某行记录加锁，它封锁该行的索引记录
    
      要注意的是：id 列必须为唯一索引列或主键列，否则上述语句加的锁就会变成临键锁。
    
      同时查询语句必须为精准匹配（=），不能为 >、<、like等，否则也会退化成临键锁
    
   间隙锁（Gap Locks）: 间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，
   而不仅仅是这个区间中的每一条数据。

   临键锁（Next-Key Locks）: Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决幻读的问题。 
   每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，
   临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。

#### MySQL 中有哪些日志？

   1、事务日志
       
       事务日志分为redo log和undo log两种；

          (1)、对于事务日志中未正常提交的事务，则会记录到undo log （回滚日志）中，因为事务未正确执行完，因此必须回滚，从而保证数据一致性
       
          (2)、对于事务日志中已正常提交但未同步到持久化存储上时，则会记录到redo log （重做日志）中，因此MySQL会重新执行一遍事务，
          然后让数据存储到磁盘上，从而保证数据一致性
       
   2、二进制日志
         
       MySQL中的二进制日志(binary log)是一个二进制文件，主要用于记录可能引起数据库内容更改的SQL语句或数据行记录，例如新增(Insert)、更新(Update)、删除(Delete)、授权信息变更(Grant Change)等，除记录这些外，还会记录变更语句的发生时间、执行时长、操作数据等额外信息，但是它不会记录诸如Select、Show等这些不会引起数据修改的SQL语句。
          
       作用：主要用于主从复制架构，日志审计
       
   3、查询日志 
       
        开启查询日志功能，会记录所有的查询操作，这在繁忙的数据库应用中会增加额外的IO开销，磁盘空间增长也会很快，不建议开启；通常用于DBA调试优化时临时开启
      
   4、慢查询日志
        
        查询日志，所有的查询都会记录；但慢查询日志会记录执行比较慢的查询语句，究竟执行多久定义为慢，这个可以通过变量long_query_time来设定，慢查询通常会开启，便于DBA进行分析并进行性能优化
        
   5、中继日志
        
        作用：中继日志主要用于在主从复制架构中，在 slave节点上开启该日志类型，用于从master同步二进制日志数据；
        
   6、错误日志
   
        记录MySQL守护进程启动和关闭过程中产生的错误信息，运行中产生的错误信息
        
#### sql_log_bin和log_bin的区别在哪里？
   
   真正决定是否生效开启二进制日志的是配置文件/etc/my.cnf中的log_bin变量，存在该配置则开启，不存在则表示不开启；
   sql_log_bin是一个动态变量，通常在会话中修改，也可以开启或关闭二进制日志，但修改时可以只针对当前会话生效，也可以针对全局生效，
   需要注意的是如果修改为全局变量时，则仅针对新建立连接生效，因此一般修改此变量为全局时，必须把旧连接KILL掉，这个需谨慎
     

#### 既然有log_bin这个服务器变量，为什么还需要sql_log_bin？
     
   当需要还原数据库数据时，如果你不关闭二进制日志，那么所有这些还原数据记录信息都会被记录到二进制日志中，这是没必要的，而且浪费磁盘空间；
   这时我们有两个方案：一种是在配置文件/etc/my.cnf中注释掉log_bin这一配置项，然后重启MySQL服务，该方案必须重启MySQL服务，
   会造成服务中断；另一个方案是直接在会话变量中设定全局sql_log_bin=OFF，则表示关闭二进制日志，*不必重启MySQL服务*，
   这便是sql_log_bin存在的价值和意义
   

#### 数据库有哪些特性？MySQL 是如何保证机器宕机重启后，数据不丢失的？
   
   ACID (原子性、隔离性、一致性、持久性) 
   
   MySQL 通过 redo log 机制，以及两阶段事务提交（prepare 和 commit）来保证了事务的持久性。
   
   MySQL 中，只有当 innodb_flush_log_at_trx_commit 参数设置为 1 时，才不会出现数据丢失情况，当设置为 0 或者 2 时，
   可能会出现数据丢失。
   
#### binlog 有什么作用？将其格式设置为 statement 会有什么问题？你们线上是如何配置的？

   作用: 
    
      1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
        
      2，用于数据库的基于时间点的还原。
   
   格式statement 会有什么问题: 
      
      主从同步会导致数据不一致
      
   
      

#### 如何保证 MySQL 的高可用？主从复制的原理？

#### 现在线上环境中发现 MySQL 的从节点大幅落后于 master 节点，可能是什么原因？如何处理？

#### 代码在执行 SQL 语句时，数据库连接出现了超时异常，但是你不知道这条 SQL 语句在数据库中究竟有没有执行成功，这种情况怎么保证数据的一致性？
    
#### MVCC 的实现原理
    
   InnoDB的MVCC是通过在每行记录后面保存两个*隐藏的列*来实现的。
   
   一个保存了行的事务ID（DB_TRX_ID），一个保存了行的回滚指针（DB_ROLL_PT）。每开始一个新的事务，都会自动递增产 生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，当查询时需要用当前事务id和每行记录的事务id进行比较。
   
### 汇总

	1) MySQL 有哪几种存储引擎，有什么区别 

		innodb、myisam、 memory 等

		1. myisam: 
			1) 数据库文件类型为: .frm、.myd、myi 三个文件， 索引文件和数据文件是分离的 
			2） 只支持表锁
			3） 不支持事务
			4) 索引 默认也是使用 b+tree ,但是具体实现有些不同
			5）优点是占用空间小，处理速度快,缺点是不支持事务的完整性和并发
			6) 不支持外键

		2. innodb： 
			1）数据库文件类型为: .frm、 ibd 两个文件, 索引文件和数据文件是一起的，通过一个聚集索引维护
			2）支持表锁、行锁
			3）支持事务
			4) 支持外键
			5）索引默认 使用的也是 b+tree 
			6) 优点是innodb 提供的良好的事务处理、崩溃修复和并发控制， 缺点是读写较差、占用数据空间相对较大

		3. memory: 
			1) 数据文件类型为: .frm ,只存储表的结构，数据是存储在内存中的
			2）索引使用的是  默认 是hash 
			3）优点是数据都存储在内存中，有利于数据的快速处理， 缺点是数据是存储在内存，重启、异常、关闭机器 数据都会消失，安全性低



	2）什么是脏读、幻读、不可重复读， 需要怎么处理

		脏写: 一个事务修改了另一个未提交事务修改的数据

		脏读: 一个事务读到了另一个事务未提交的事务 

		不可重复读: 一个事务读到了另一个事务提交的数据 

		幻读: 一个事务读到了另一个事务新增的数据

		解决:
		1. 脏读、幻读、不可重复读、幻读、其实都是数据库读一致性问题，必须由数据库提供一定得事务隔离机制来解决。
		2. 加锁
		3. mvcc机制



	3) 事务的基本特性 和隔离级别有哪些

		事务的基本特性: 

			原子性：事务是不可分割的，要么同时成功，要么同时失败

			一致性: 事务无论是成功还是失败，都必须保持事务内操作的一致, 当失败时，都要对前面的操作进行回滚

			隔离性: 当多个事务操作同一数据时，为防止数据损坏，需要将每个事务进行隔离，互相不干扰

			持久性: 事务完成后，对于数据的修改是永久性的，即使出现故障也能保持。


		事务的隔离级别:

			读未提交: 一个事务读取到另一个事务未提交的数据,  会产生脏读、不可重复读、幻读

			读已提交: 一个事务只能读到另一个事务已经提交的数据。   会产生 不可重复读、幻读问题,    解决了 脏读问题 
 
			可重复读： 一个事务多次读取到的数据是一致的，即使其他事务修改了数据，读的还是第一次读取到的值  会产生 幻读 问题,  解决了 脏读、不可重复读问题

			串行化: 事务间串行执行



	4） mysql 的锁有哪些？ 什么事间隙锁、临键锁 

		从锁的粒度分：

			行锁: 加锁粒度小，资源开销大，innodb 支持


			表锁: 加锁粒度大，资源开销小， myisam 、innodb 都支持

			全局锁: flush tables with read lock ，加锁之后整个数据库实例都处于只读状态，所以数据的变更操作都会被挂起，一般用于全库备份的时候。

		从锁的性能上分: 

			乐观锁(加版本号控制)

			悲观锁

		从锁的操作上分:

			读锁(共享锁): 同一份数据，多个读操作可以同时进行而互不影响

			写锁(排它锁): 只有一个事务能过获取锁，其他事务都不能获取锁 ， innodb 会对 update、delete、insert 语句 字段加排他锁 ,也可手动对 selete 语句手动加锁(selete * from for update )

			自增锁: 通常是针对mysql 当中的自增字段，如果有事务回滚，数据会回滚，但是自增序列不会回滚。


		从锁的算法分:  user userid (1,4,9) 三条记录

			记录锁: 行锁 (update set xxx where userid = 5;) , 锁的是一条具体的数据 

			间隙锁： 锁的是两个值直接的空隙(开区间)，锁的是范围，而不是具体的记录,  mysql 默认是 可重复读级别生效,在某些情况下可以解决幻读问题

				（-xx,1）(1,4) (4,9) (9,xxx) 

			临键锁: 左开右闭区间，特殊的隙锁。  间隙锁+右记录锁 (-xx,1] ,(1,4], (4,9], (9,xx) 


	5） mysql 的索引是什么？ 索引原理，设计原则等 

		索引: 是帮助mysql高效获取数据的 排好序的数据结构

		索引原理: 

			首先索引是在mysql存储引擎层实现的，而不是服务层实现的，索引每种存储引擎的索引都不一定完全相同.

			mysql 的innodb 实现了两种 数据结构的索引 ，b+tree 和 hash 表, myisam 存储引擎 也实现了 b+tree 和 hash 表

			索引数据结构的进化: 二叉树 > 红黑树 > b-tree > b+tree 

			二叉树: 每个节点最多只有两个字节点，左边的子节点都比当前节点小，右边的节点都比当前节点大

				   利用索引查询时，不可能把整个索引树都加载到内存中去，只能逐一加载每个磁盘页，磁盘页对应索引树的节点，mysql 衡量查询效率的标准就是磁盘IO的次数
				   为了减少磁盘io的次数，就得减少树的高度， 但是二叉树在极端的情况下，会蜕变为链表， 因此不适合做为mysql的索引

			红黑树: 也是平衡二叉树, 每个节点都是红色或黑色，根节点是黑色，，每个叶子节点都是黑色的空节点 

					通过自旋的方式对树进行平衡处理，解决不会像二叉树一样单边增长，但是当数据量大的时候，红黑树的深度还是会很深 

			b-tree: b-tree 是一种平衡的多叉查找树，也就是说最多可以开m个叉，称之为m阶b树。

					叶子节点具有相同的深度，也节点的指针为空
					所有索引元素不重复
					节点的数据索引从左到右递增
					每个节点都存储了数据，由于每个节点都存储了数据，所以每个节点所容纳的索引就不会太多，因为节点都是有容量限制的，每次io查出来的数据量不会太大，因此查询效率也不高。

			b+tree: b-tree 也是一种平衡的多叉查找树，也就是说最多可以开m个叉，称之为m阶b树。 b-tree 的加强版

					非叶子节点不存储数据，只存储索引,索引可以放更多的索引.
					叶子节点包含所有的索引字段
					叶子节点用指针连接(双向指针)，提供区间访问能力
					索引元素有重复。


					b+tree 是通过把data 不放在非叶子节点上来增加度(小节点)，从而一次IO可以查询出更多的索引数据，减少查询次数，
					并且，叶子节点直接会有指针，数据又是递增,使得范围插座可以通过指针连接，而不用从上面节点往下一个个找
					从上可以看到b+tree 即减少了查询次数，又提供了很好的范围查找， 索引mysql 默认使用 b+tree 作为索引结果


			hash表: hash 索引是一种常见的索引，单条记录查询效率很高(比b+tree高，因为通过一次hash计算就能定位出数据存储的位置)。

					但是hash索引并不是常有的数据库索引类型，
					因为hash索引不支持范围查找。
					同时也会出现hash 冲突问题


		索引设计原则: 

			1. 查询频次高，数据量大的表 

			2. 代码先行，索引后上

			3. 联合索引尽量覆盖条件

			4. 不要在小基数的字段上建索引

			5. 长字符串可以采用前缀索引

			6. where 与order by 冲突时优先where 

			7. 基于慢sql查询做优化


	6） msyql 怎么调优、慢sql 怎么优化(explain分析sql), 常见优化场景等


		怎么调优：

			1. 合理的创建索引, 

			2. 通过explain 关键字来分析sql 语句，优化sql 语句。

			3. 尽量使用覆盖索引

		常见优化场景: 

			1. order by 排序

			2. group by 分组

			3. 优化子查询

			4. 优化 or 条件

			5. 优化 limit 分页 


	7) mysql 索引失效？ 失效的原因是什么？ 

		索引失效:

			1. 对索引使用左或者左右模糊匹配   因为不满足 最左匹配原则

			2. 对索引使用函数    			  因为索引保存的是索引字段的原值，而不是经过计算的值，所以就没办法走索引

			3. 对索引使用表达式             同上

			4. 对索引使用隐式类型转换(int 转string)  因为使用到了函数cast ,导致无法走索引        

			5. 联合索引非最左匹配           不满足最左匹配原则

			6. where 子句中的or    		 因为or的含义是两个只要满足一个即可，因为只有一个条件列是索引列是没有意义的，只要有条件不是索引列，就会全表扫描



	8) mysql order by 是怎么排序的？ 需要怎么优化 ？

		filesort 文件排序: 
			1. 单路排序： 一次性取出满足条件行的所有字段，然后在sort buffer 中进行排序 

			2. 双路排序(也叫回表排序): 是首先根据相应的条件取出相应的排序字段和可以直接定位行的id,然后在sort buffer 中进行排序，排序完之后再回表取它所需要的字段

		优化: 

			1. 对需要排序的字段加索引，从而尽量在索引列上完成排序

			2. 使用覆盖索引优化排序

	9）一千万数据，怎么快速查询？ 

		如果使用 普通分页查询的话，也会导致查询慢问题，是因为分页排序是参与偏移量进行分页，先取出所有数据，然后再进行截取，这样实际上还是查询出大量数据

		优化: 

			1. 优化偏移量大的问题， 使用子查询的方式，先定位偏移量的位置id ,然后再查询数据 (但是只适用于id自增的情况)

			2. 采用id 自增的方式

			3. 减少不需要的列，按需要查询相应的列