### java 基础篇 
   
#### 1. java 字符型常量和字符串常量的区别?
   
   形式上: 字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或若干个字符
   
   含义上: 字符常量相当于一个整型值(ASCII),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)
   
   占用内存大小 字符常量只占用2个字节； 字符串常量站占干个字节
   
#### 2. String 和StringBuilder 、StringBuffer 的区别?
   
   java 提供了三种类型的字符串: String、StringBuffer、StringBuilder ，它们可以存储和操作字符串.
   
   其中String 是只读 字符串，也就意味着String 引用的字符串内容是不能被改变的。
   
   StringBuffer/StringBuilder 类表示的字符串对象可以直接修改。StringBuilder 是java 5 中引入的，它和StringBuffer 的方法完全相同，
   区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized 修饰,因此它的效率也比StringBuffer 要高。
   
#### 3. 反射的用途及实现
   
   java 反射机制是一个非常强大的功能，在很多框架中比如Spring mybatis 都可以看到反射。通过反射机制，我们可以在运行期间获取对象的信息。
   利用这个我们可以实现工厂模式和代理模式等设计模式。
   
   获取一个对象的反射类，有以下3种方式
      
      new 一个对象，然后对象.getClass() 方法
      
      通过 Class.forName() 方法
      
      使用 类.class

#### 4. String s= "abc" 和String s = new String("abc") 区别
    
   new String("abc") 在内存中创建了几个对象 答案是：一个或者两个
    
   1. 首先在堆中(不是常量池)创建一个指定的对象 "abc", 并让s 引用指向该对象
    
   2. 在字符串常量池中查看，是否存在内容为"abc" 字符串对象
    
   3.若存在，则将new 出来的字符串对象与字符串常量池中的对象联系起来
    
   4.若不存在,则在字符串常量池中创建一个内容为 "abc" 的字符串对象,并将堆中的对象与之关联起来
    
####  5. java 中的SPI 


#### 6. java 8 有哪些特性
   
   1. 函数式接口
   
   2. 接口可以有实现方法，而且不需要实现类去实现其方法
   
   3. lambda 表达式
   
   4. strram 流 
   
   5. 日期时间API LocalDateTime 年月日时分秒 LocalDate 日期, LocalTime 时间
   
   6. Optional 类
   
#### 谈谈对⾯向对象（OOP）思想的理解？
   
   将复杂的事物抽象成为一个个个体，每个个体皆为对象，每个对象去处理自己的方法。
   
   优点: 易扩展、维护、复用。
   
   缺点: 性能低，因为封装，初始化需要实例化，比较耗资源.
   
   OOP 三大特征: "封装、继承、多态"
   
   理解：面向对象是把一组数据结构和处理他们的方法组成对象；把具有相同行为的对象归纳成类；
   通过封装隐藏类的内部细节；通过继承试类得到泛化；通过多态实现基于对象类型的动态分派；
       
#### == & equals 的区别
   
   "==": 比较基本数据类型是比较数值； 引用类型比较的是内存地址
   "equals": 判断两个变量或实例所指向的内存空间的值是否相同(比较内容是否相等)

#### final 
   
   1. "final 修饰类" : 不可被继承 ，（拓展）避免滥用继承带来的危害
       
      继承缺点： 打破了封装性，和父类耦合，父类更新后可能会导致错误。 "复合优先于继承"
      "创建一个新的类，在新的类中添加私有域，引用现有类的一个实例，这种设计叫做复合"
   
   2. "final 修饰方法": 不可重写
   
   3. "final 修饰成员变量" 变量值不能被更改
   
#### 接口和抽象类的区别
   
   1. "抽象类" 是用来捕捉子类通用特性的，描述一种事物，不能被实例化，只能被用作子类的超类,抽象类是被继承的子类模板。
   
   2. "接口" 接口是抽象方法的集合，是对类行为进行抽象
   
   区别:
      
      1. "抽象类" 可以有默认方法的实现， "接口" 完全是抽象的，不存在方法的实现 (java8 之后允许接口有默认方法)
      
      2. "抽象类" 子类使用extends 来继承抽象类，如果子类不是抽象类，它必须提供抽象类里声明的所有抽象方法的实现方法.
            "接口" implements 来实现接口，需要提供所有接口声明的抽象方法的实现方法。
            
      3. "抽象类" 可以有构造器
      
      4. "抽象类" 可以有main 方法并且可以运行
      
      5. "接口" 是可以实现多继承
      
      6. "接口" 速度较慢，因为它需要去寻找类中的实现方法.
      
      7. "抽象类" 添加新方法可以给默认实现，所以不需要声明新方法的实现。接口可以用 "default" 一样的

#### int 和Integer 的区别
   
   Integer 是int 的包装类，Integer 必须实例化才可以使用 "有了自动装箱拆箱机制之后，也可以直接使用"
   
   "IntegerCache" 缓存 -128~127 之间的数值，不会new 新的Integer 对象，而是直接引用内存中常量池的对象
   
#### 什么是向上转型？ 什么是向下转型？ 
   
   1.向上转型： 一定是安全的，"子类转化成父类"
   
   2.向下转型: 是不安全的 "前提条件是子类还是原来的子类，否则会报转换异常"
   
#### 方法重写 与重载的区别
   
   "重写" 发生再父类子类中，参数方法名相同
   
   "重载" 发生再类里，方法名相同，参数不同

#### List 和 Set 区别
   
   "list" 有序、重复
   
   "set" 无序、不重复
    
        "无序不是可排序，而是加入的顺序是随机的"

#### ArrayList 和 LinkedList 的区别

   1. "数据结构不同": ArrayList 是基于动态数组， LinkedList 是基于链表
   
   2. "查" ArrayList 支持随机访问(下标index访问)，链表不支持高效随机访问的
   
   3. "改" ArrayList 在列表末尾增加一个元素开销是固定的。LinkedList 修改数据开销是统一的。在ArrayList 
   的中间插入或删除一个元素意味着这个列表的剩余的元素都会被移动；
   
   4. "空间" ArrayList 的空间浪费主要体现在list列表的结尾预留一定的容量空间，而LinkedList 的空间花费则体现在它的
   每一个元素都需要消耗相当的空间
   
   5. "总结": 当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList 会提供比较好的性能;
   当你的操作是在一列数据的前面或中间添加或删除数据，并且安装顺序访问其中的元素时，就应该使用LinkedList 了。
   
#### 实现线程的方式
   
   继承Thread 
       
      "优点": 可以用this直接获取当前线程
      
      "缺点": 因为java是不支持多继承的，所以不能再继承其他的父类了
   
   实现Runable接口
        
      "优点"： 可以继承其他对象，这样就可以多个线程共享同一个目标对象了
      
      "缺点": 代码复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法.
        
   实现Callable 接口 (可以获取线程执行之后的返回值)
        
      "优点": Callable 的任务执行后可返回值
   
   Runable 和 Callable 的区别:
      
     (1)(Callable) 规定的方法是call(), Runable 规定的方法是run()
     
     (2) Callable 的任务执行后可返回值，而Runable 的任务是不能返回值的
     
     (3) call 方法可以抛出异常，run 方法不可以，因为run 方法本身没有抛出异常，所以自定义的线程类在重写run
     的时候也无法抛出异常
     
     (4) 运行Callable 任务可以拿到一个Future 对象，表示异步计算结果。它提供了检查计算是否完成的方法，以等待计算完成，并检索
     计算的结果。通过Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

#### 谈谈 Sleep 和wait 的区别
    
   1.sleep 不会释放锁，wait 会释放
   
   2.wait 只能在同步(synchronize) 环境中被调用，而sleep 不需要。
   
   3. 进入wait 状态的线程能够被notify 和notifyAll 线程唤醒，但是进入sleeping 状态的线程不能被notify 方法唤醒
   
   4. wait 通常有条件地执行，线程会一直处于wait 状态，直到某个条件变为真。但是sleep 仅仅让你的线程进入睡眠状态。
   
   5. wait 方法是针对一个被同步代码块加锁的对象，而sleep 是针对一个线程。 
       
       