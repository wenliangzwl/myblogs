### 中间件 题目

#### RocketMQ 的实现原理。

#### Zookeeper 作为注册中心的实现原理？

#### Zookeeper 实现分布式锁的原理？

#### RocketMQ 事务消息的实现原理？你们的项目中是如何通过 RocketMQ 来保证数据一致性

#### RocketMQ 的实现原理？消息时如何存储的？

#### 线上出现 MQ 丢失消息？问题可能出现在哪儿？如何保证 MQ 的消息不丢失？

#### 如何保证 RocketMQ 的高可用性？

#### RocketMQ 的事务消息的实现原理？

#### 如何保证消息的顺序性？


rabbitmq 顺序性 

    拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确 实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

消息有序指的是可以按照消息的发送顺序来消费。 
    
    假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？

解决方案： 
    
    （1）保证生产者 - MQServer - 消费者是一对一对一的关系

缺陷： 
    
    并行度就会成为消息系统的瓶颈（吞吐量不够） 
    更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我 们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解 来规避。
    不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依 
    赖于消息系统，是一种更合理的方式。

#### 如何保证消息不被重复消费？

造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收 到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消 息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与 去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。

#### 如何用 Zookeeper 实现分布式锁？存在什么问题？

#### 消息队列的选型？RocketMQ 的实现原理？

#### 如何保证消息不丢失？如何保证不重复消费消息？



#### 线上 MQ 出现消息大量积压，应该如何处理？

   消息积压情况：
      
       1. 消费者宕机积压
       2. 消费者消费能力不足
       3. 发送者发流量太大
   
   解决方案：

        1. 上线更多的消费者，进行正常消费上线专门的队列消费服务，将消息先批量取出来，记录数据库，再慢慢消费

#### 让你设计一个 MQ，你会如何设计？

#### 什么是 mmap？

#### Zookeeper 集群如何部署？Zookeeper 如何实现选举？什么是 ZAB 协议？

#### Zookeeper 如何保证数据的顺序一致性？

#### Zookeeper 的使用场景？如何支撑大量的读请求？

#### 你们微服务的注册中心是如何选型的？Zookeeper 和 Eureka 作为注册中心的区别？它们有什么瓶颈？

#### 如何设计一款能支撑数十万机器组成的集群的注册中心？

#### 如何设计一个秒杀系统？在双十一当天，从浏览器中输入 www.taobao.com 到加载出页面，说一下它的完整过程。

#### zookeeper 是如何保证事务的顺序一致性的

    zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在 被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产 生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候， 会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果 超过半数的机器都能执行并且能够成功，那么就会开始执行。

#### Elasticsearch与MySQL对应关系表

![](interview.assets/es与mysql对应.png)

    MySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。

    MySQL 中一个数据库下面有 N 张表（Table），等价于1个索引 Index 下面有 N 多类型（Type）。

    MySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于1个 Type 由多个文档（Document）和多 Field 组成。

    MySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。

    MySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT/POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。

    MySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。

    MySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。

    MySQL 中的数据迁移等价于 ES 中的 reindex 操作。

#### PUST 和 PUT 的区别 

    PUST 和 PUT 都能起到创建和更新的作用 

    1. PUT 需要对一个具体的资源进行操作也就是要确定id才能进行 更新/创建，而POST是可以针对整个资源集合进行操作的,如果不写id 就由es 生成一个唯一的id，如果填了id 那就针对这个id的文档进行创建/更新

    2. PUT 只会将json 数据都进行替换，POST 只会更新相同字段的值

    1. PUT 和 DELETE 都是幂等性操作，即不论操作多少次，结果都一样。 
   
#### 安装 Elasticsearch 需要依赖什么组件吗？
    
    ES 早期版本需要JDK，在7.X版本后已经集成了 JDK，已无需第三方依赖。



