### Java服务，CPU100%问题如何快速定位？
  
  简要步骤如下：
  
  （1）找到最耗 CPU 的进程；
  
  （2）找到最耗 CPU 的线程；
  
  （3）查看堆栈，定位线程在干嘛，定位对应代码；
  
#### 步骤一、找到最耗 CPU 的进程

    工具：top
    
    方法：
    
    执行 top -c ，显示进程运行信息列表
    
    键入 P (大写 p)，进程按照 CPU 使用率排序
    


   
   如上图，最耗 CPU 的进程 PID 为 10765。
   
#### 步骤二：找到最耗 CPU 的线程
   
   工具：top
   
   方法：
   
   top -Hp 10765 ，显示一个进程的线程运行信息列表
   
   键入 P (大写 p)，线程按照 CPU 使用率排序
   
   ![](jvm.assets/cpu100-2.jpg)
   
   如上图，进程 10765 内，最耗 CPU 的线程 PID 为 10804。
   
   
#### 步骤三：查看堆栈，定位线程在干嘛，定位对应代码

   首先，将线程 PID 转化为 16 进制。
   
   工具：printf
   
   方法：printf "%x\n" 10804
   
   ![](jvm.assets/cpu100-3.png)
   
    如上图，10804 对应的 16 进制是 0x2a34，当然，这一步可以用计算器。
   
    之所以要转化为 16 进制，是因为堆栈里，线程 id 是用 16 进制表示的。
   
   
   接着，查看堆栈，找到线程在干嘛。
   
   工具：jstack
   
   方法：jstack 10765 | grep '0x2a34' -C5 --color
   
    打印进程堆栈
   
    通过线程 id，过滤得到线程堆栈
    
   ![](jvm.assets/cpu100-4.jpg)
   
   如上图，找到了耗 CPU 高的线程对应的线程名称 “AsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。
   最后，根据堆栈里的信息，找到对应的代码.
   
   
### JVM运行情况预估 

   用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的 JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。 

#### 年轻代对象增长的速率 
   
   可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不 同的时间分别估算不同情况下对象增长速率。
   
#### Young GC的触发频率和每次耗时 
   
   知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。

#### 每次Young GC后有多少对象存活和进入老年代 
   
   这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden， survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次 Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。 

#### Full GC的触发频率和每次耗时 

知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。 

#### 优化思路
   
   其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。
   



