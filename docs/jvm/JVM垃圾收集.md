### jvm 垃圾收集
   
#### 垃圾收集算法
   
  ![](jvm.assets/垃圾收集算法.png)

##### 分代收集理论(算法)
   
   目前虚拟机的垃圾收集都采用分代收集算法,主要是根据对象存活周期的不同将内存划分为几块不同区域，一般将堆分为年轻(新生)代和老年代, 这样就可以根据不同年代的特点使用不同的算法
   
   比如:年轻代中,每次收集都会有大量对象死去,所以可使用负责算法，将少量的对象复制出去就可以完成垃圾收集。老年代中,对象的存活率是比较高的，而且也没有额外的空间进行分配担保，所以
   需要选择 "标记-清除" 或 "标记-整理" 算法。 
   
   注意: "标记-清除" 或 "标记-整理" 算法会比复制算法慢10倍以上。
   
##### 复制算法
   
   为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。
   当这一块的 内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对 内存区间的一半进行回收。
   
   优点：每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
   
   缺点：算法的代价是将内存缩小为了原来的一半，未免太高了一点。
   
   ![](jvm.assets/复制算法.png)
   
##### 标记-清除算法
   
   算法分为“标记”和“清除”两阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标 记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。
   
   它是最基础的收集算法，比较简单，但是会带来 两个明显的问题： 
    
    1. 效率问题 (如果需要标记的对象太多，效率不高) 
    
    2. 空间问题（标记清除后会产生大量不连续的碎片）
   
   ![](jvm.assets/标记-清除算法.png)
   
##### 标记-整理算法
   
  根据老年代的特点推出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，
  然后直接清理掉端边界以外的内存。
   
  ![](jvm.assets/标记-整理算法.png)

#### 垃圾收集器
  
  垃圾收集算法只是内存回收的方法论，垃圾收集器才是内存回收的具体实现.
  
  目前为止,没有哪一种垃圾收集器是最合适的，只有不同应用场景下适用不同的垃圾收集器。
    
  ![](jvm.assets/) 
   
##### Serial (串行)收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)
   
   Serial 收集器是最基本，时间最长的垃圾收集器，它是一个单线程收集器，它的"单线程" 的意义不仅仅意味着它只会适用一个垃圾收集线程去完成垃圾收集工作，
   更重要的是它再进行收集的过程中，必须暂停其他所有的工作线程(Stop The World -STW)，直到收集结束.
   
   年轻代采用复制算法,老年代采用标记-整理算法.
   
   ![](jvm.assets/Serial收集器.png)
   
   Serial 优于其他垃圾收集器的地方就是*简单而高效(和其他收集器的单线程相比)*,因为没有线程交互的开销，所以可以获得很高的单线程手机效率.
   
   Serial Old 是Serial 的老年代版本,同样是一个单线程收集器，主要的两大用途为: 在JDK1.5及以前的版本与Parallel 搭配使用 和 作为CMS 的后备方案.
   
##### Parallel Scavenge (并行) 收集器(-XX:+UseParallelGC ,-XX:+UseParallelOldGC)
   
   Parallel 是 Seruial 的多线程版本,除了使用多线程进行垃圾收集，其余行为(控制参数、收集算法、回收算法等)，和Serial 类似。
   它的默认收集线程数跟cpu核数相同，但是也可以用参数(-XX:ParallelGCThreads)指定收集线程数，一般不推荐修改。
   
   Parallel 关注的是吞吐量(高效率的利用CPU). CMS 等其他垃圾收集器关注更多的是用户线程的停顿时间(主要为了提高用户体验)。吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值.
   
   年轻代采用复制算法，老年代采用标记-整理算法
   
   ![](jvm.assets/Parallel垃圾回收器.png)
   
   Parallel Old 是 Parallel Scavenge 的老年代版本, 在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel 和Parallel Old (是JDK8 默认的新生代和老年代收集器)
   
##### ParNew 收集器(-XX:+UseParNewGC)
   
   ParNew  是Serial 的多线程版本, 是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法(复制算法)、STW、对象分配
   规则、回收策略等与Serial 完全相同)
   
   年轻代采用复制算法,老年代采用标记-整理算法.
   
   ![](jvm.assets/parNew收集器.png)
   
   是许多运行在Server模式下的虚拟机的首要选择，除了Serial 外，只有它能与CMS 收集器配合工作。
   
##### CMS 收集器(-XX:+UseConcMarkSweepGC(old))
   
   CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。非常符合在注重用户体验的应用上使用，是HotSpot
   第一款真正意义上的并发收集器,也是第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。
   
   CMS 采用的是 标记-清除算法实现, 它的运作过程相比于其他的垃圾收集器来说更加复杂一些，主要步骤为:
   
    初始标记: 暂停所以的其他线程(STW),并记录gc roots 直接能引用的对象，速度很快.
    
    并发标记: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 
            可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。
    
    重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对 象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
            主要用到三 色标记里的增量更新算法做重新标记。
   
    并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理.
    
    并发重置： 重置本次GC过程中的标记数据。
    
   ![](jvm.assets/CMS收集器.png)
   
   