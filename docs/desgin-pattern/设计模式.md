### 什么是设计模式？

   设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
   
   设计模式不是工具， 它是软件开发的哲学， 它能指导你如何去设计一个优秀的架构、 编写一段健壮的代码、 解决一个复杂的需求 。
   
   
   
   行业内总结的设计模式非常非常多，其中最出名的是GOF书中提到的23种设计模式。
   
   这23种设计模式又分为创建型、结构型、行为型三类。
   
   **创建型**：顾名思义，如何去创建某个对象。取代最简单的new的方式
   
   **结构型**：站在软件结构上，怎么要我们的代码更简洁、灵活，更有扩展性。
   
   **行为型**：站在方法角度，让我们的方法设计和调用更为合理

### GOF 23种设计模式
   
   1.创建型模式
    
   共五种：工厂方法模式、抽象工厂模式、单例模式、原型模式、建造者模式。
   
   2.结构型模式
   
   共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
   
   3.行为型模式
   
   共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 软件设计原则
 
   1.  开闭原则              ---》 开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；
   
   2. 依赖倒置原则            ---》依赖倒置原则告诉我们要面向接口编程
   
   3. 单一职责原则            ---》单一职责原则告诉我们实现类要职责单一
   
   4. 接口隔离原则            ---》接口隔离原则告诉我们在设计接口的时候要精简单一
   
   5. 迪米特法则（最少知道原则） ---》迪米特法则告诉我们要降低耦合度
   
   6. 里氏替换原则            ---》 里氏替换原则告诉我们不要破坏继承体系；
    
   7. 合成/复用原则           ---》合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
#### 开闭原则
   
   对扩展开放， 对修改关闭
   
   其含义是说一个软件实体应该通过扩展来实现变化， 而不是通过修改已有的代码来实现变化。
#### 依赖倒置原则
   
   1.高层模块不应该依赖底层模块，二者都应该依赖其抽象
   
   2.抽象不应该依赖细节
   
   3.细节应该依赖抽象
   
   核心思想：要面向接口编程，不要面向实现编程。
   
   作用：
    
    ·依赖倒置原则可以降低类间的耦合度
    
    ·依赖倒置原则可以提高系统的稳定性
    
    ·依赖倒置原则可以减少并行开发引起的风险
    
    ·依赖倒置原则可以提高代码的可读性和可维护性
   
   实现方法：
    
    ·每个类尽量提供接口或者抽象类，或者两者都具备。
    
    ·变量的声明类型尽量是接口或者抽象类。
    
    ·任何类都不应该从具体类派生
    
    ·使用继承时尽量遵循里氏替换原则

#### 单一职责原则 (单一功能原则)
   
   该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
        
        1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
        
        2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
   
   核心:控制类的粒度大小、将对象解耦、提高其内聚性.
   
   优点:
   
       1.降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
       
       2.提高类的可读性。复杂性降低，自然其可读性会提高。
       
       3.提高系统的可维护性。可读性提高，那自然更容易维护了。
       
       4.变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。
   
   实现:
       
       单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。
       而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

#### 接口隔离原则
   
   1.一个类对一个类的依赖应该建立在最小的接口上
   
   2.建立单一接口，不要建立庞大臃肿的接口
   
   3.尽量细化接口，接口中的方法尽量少
   
   优点：
   
     ·将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
   
     ·接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
   
     ·如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
   
     ·使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
   
     ·能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。
   
   实现方法：
      
      ·接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
    
      ·为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
    
      ·了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
    
      ·提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

#### 迪米特法则（最少知道原则）

  
   迪米特法则（Law of Demeter, LOD） 也称为最少知识原则（Least Knowledge Principle,LKP)
   
   优点:
    
    ·降低了类之间的耦合度，提高了模块的相对独立性。
    
    ·由于亲合度降低，从而提高了类的可复用率和系统的扩展性。
    但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。
    所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
   
   实现方法：
    
    ·从依赖者的角度来说，只依赖应该依赖的对象。
    
    ·从被依赖者的角度说，只暴露应该暴露的方法。
    
    ·在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
    
    ·在类的结构设计上，尽量降低类成员的访问权限。
    
    ·在类的设计上，优先考虑将一个类设置成不变类。
    
    ·在对其他类的引用上，将引用其他对象的次数降到最低。
    
    ·不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
    
    ·谨慎使用序列化（Serializable）功能。

#### 里氏替换原则
   
   父类能出现的地方子类就可以出现，而且替换为子类也不会产出任何错误或异常，
   
   使用者可能根本不需要知道是父类还是子类。
   
   但是反过来不行，有子类出现的地方，父类未必就能适应
   
   里氏替换原则的主要作用如下:
   
     1.里氏替换原则是实现开闭原则的重要方式之一。
  
     2.它克服了继承中重写父类造成的可复用性变差的缺点。
   
     3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
   
   里式替换原则注意事项:
   
      1.子类可以实现父类的抽象方法，但是不建议覆盖父类非抽象方法。
   
      2.子类中可以增加自己特有的方法。
   
      3.当子类的方法重载父类的方法时，方法的入参要比父类方法的入参更宽松 （HashMap、Map）
   
      4.当子类重写/重载或者实现抽象方法，方法的返回值要比父类更严格或相等。

#### 合成/复用原则
   
   它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
   
   如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。
   
   合成复用原则的重要性:
      
      通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
      
      继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
      
      子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
      
      它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
    
      采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
      
      它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
      
      新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
      
      复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。